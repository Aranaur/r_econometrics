# Маніпуляції з даними за допомогою dplyr {#dplyr}
***
```{r setup-02, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, collapse = TRUE, out.width = '100%')
```

В минулій главі ми розібрали основні принципи мови програмування R. І тут слід зазначити, що окрім базового синтаксису існують й інші. Загалом, можна виділити три основні діалекти в мові програмування R:

* base: основний фундамент мови, який ми розібрали (але не повністю) раніше.

* Tidyverse: окремий напрямок розвитку мови програмування R, що сконцентрований у напрямку науки про дані (data science).

* data.table: альтернативний напрямок, який дозволяє оброблювати об'ємні масиви даних за рекордний час @h2obench.

Їх можна сміло поєднувати в своїх проектах, що значним чином підвищує ефективність та швидкість роботи.

##  Tidy-всесвіт {#tidy}
***
[**Tidyverse**](https://www.tidyverse.org/) --- це екосистема, набір пакетів, які спеціально створені для науки про дані (data science). В ньому є ключові пакети (ядро tidyverse) та побічні --- які додатково розширюють можливості мови програмування R.

**Концепція охайних даних (tidy-data)** передбачає приведення даних до формату, в якому:

* Кожна змінна міститься в окремому стовпчику

* Кожне спостереження міститься в окремому рядку

* Кожне значення міститься в окремій комірці

**Ядро tidyverse:**

* *ggplot2*, для візуалізації

* *dplyr*, для маніпуляції з даними

* *tidyr*, для отримання охайних даних (tidy data)

* *readr*, для зчитування та записування файлів в R

* *purrr*, для функціонального програмування

* *tibble*, для роботи з тібблами (tibble), просунутий варіант дата фреймів

* *stringr*, для роботи з текстовими даними

* *forcats*, для роботи з факторами (factors)

Крім того є ще низка допоміжних пакетів, які не входять до ядра tidyverse але вважаються його частиною:

* *vroom*, для швидкого завантаження даних

* *DBI*, для роботи з базами даних

* *haven*, для даних SPSS, Stata та SAS

* *httr*, для роботи з API

* *readxl* для завантаження .xls та .xlsx файлів

* *googlesheets4*, для роботи з Google Sheet

* *googledrive*, для роботи з Google Drive

* *rvest*, для скрапінгу веб-сторінок

* *jsonlite*, для роботи з JSON-файлами

* *xml2*, для роботи з XML

* *lubridate*, для роботи з датами

* *dbplyr*, для перетворення коду `dplyr` в SQL

* *dtplyr*, для перетворення коду на `data.table`

* *magrittr*, для використання конвеєрів `%>%` (pipe)

* *glue*, для поєднання даних та тексту

* *tidymodels*, для роботи з моделями машнинного навчання.

І це ще не повний список. Крім офіційних пакетів tidyverse є ще низка пакетів, які намагаються відповідати принципам tidyverse і доповнюють його.

Головним чином, для роботи з даними, я зосереджу свою увагу на роботі з пакетом `dplyr`.

Для завантаження tidyverse необхідно виконати наступний код:
```{r tidyinstall, eval=FALSE}
install.packages("tidyverse")
```
Для підключення:
```{r tidyload, eval=FALSE}
library("tidyverse")
```

Концепція "охайних" даних передбачає альтернативу класичним `data.frame` у вигляді тібблів (`tibble`). Давайте розеберемо основі відмінності.
В мові програмування R є вбудований популярний датасет `iris`. Він зберігається в форматі дата фрейму.
```{r iris}
# Переглянемо перші декілька значень
head(iris)
```

Давайте створемо його альтернативу у вигляді тібблу:
```{r iristbl}
iris_tbl <- as_tibble(iris)
iris_tbl
```

Вже на цьому етапі видні основні відмінності: тіббл відображає одразу перші 10 спостережень і всі ствопчики, які поміщаються на екрані. Крім того до кожного стовпчика вказується його тип. Це дуже зручно, особливо коли працюєте з великим об'ємом даних.

## Завантаження даних {#tidy_read}
***
### Завантаження .csv, .tsv файлів {#tidy_csv}
Стандартною функцією завантаження даних типу `.csv` є функція `read.csv()`, але на досить великих масивах даних краще використовувати `read_csv()` з пакету `readr`. Синтаксис цих функцій схожий, але `read_csv()` одразу приведе дані до формату `tibble`.
Першим аргументом функції є шлях до файлу (із оберненим слешем `/`). Також можна використовувати прямі URL-посилання на файл: 
```{r eval=FALSE}
read_file <- read_csv("docs/data/file.csv")
read_url <- read_csv("https://git.io/JztOr")
```

Аналогічно до `read_csv()` можна використовувати функцію `vroom` з однойменного пакету. Головною особливістю цього пакету є [швидкість завантаження даних](https://cran.r-project.org/web/packages/vroom/vignettes/benchmarks.html).
```{r eval=FALSE}
vroom_file <- vroom("docs/data/file.csv")
vroom_url <- vroom("https://git.io/JztOr")
```

Для **завантаження** одночасно **декількох файлів однакової структури** корисно використовувати наступну конструкцію
```{r eval=FALSE}
filse <- dir(pattern = "\\.csv$")
vroom_all <- vroom(filse)
```

### Завантаження .xls, .xlsx файлів {#tidy_xls}
Для завантаження файлів **Excel** використовується пакет `readxl` та функція `read_excel()`.
На початку можна отримати перелік листів файлу Excel за допомогою функції `excel_sheets()`
```{r}
readxl::excel_sheets("docs/data/tourism.xlsx")
```
Після чого зчитати данні з потрібного листа
```{r eval=FALSE}
excel_file <- read_excel("docs/data/tourism.xlsx", sheet = "Sheet1")
```

В більшості випадків цього інструментарію має бути достатньо, але для завантаження специфічних файлів завжди можна знайти потрібний пакет. Не соромтеся використовувати google.


## Маніпуляції з даними за допомогою пакету dplyr {#dplyr}
***
dplyr - це граматика маніпуляції з даними, яка має низку функцій, які допоможуть легко та зручно маніпулювати даними, наприклад:

* створювати нові змінні

* сортувати дані

* проводити фільтрацію даних

* агрегування даних і багато іншого.

В якості прикладу роботи з пакетом dplyr пропоную використати датасет `gapminder` з однойменного пакету. В ньому збережена інформація про ВВП, очікувану тривалість життя при народженні та населення для 142 країн світу з 1952 по 2007 роки.
```{r gapminder}
# Підключаємо пакет (не забудьте його встановити) та подивимось на датасет
library(gapminder)
gapminder
```

Видно, що змінні `country` та `continent` --- це фактори, а всі інші --- числові.

### dplyr::glimpse() {#glimpse}
Для перегляду структури тібблу використовується функція `glimpse()`:
```{r glimpse}
glimpse(gapminder)
```
Це альтернатива базовій функції `str()` для дата фреймів.

### dplyr::filter() {#filter}
Для фільтрації спостережень за певною умовою використовується функція `filter()`. Для прикладу відфільтруємо дані для Ірландії:
```{r filter01}
filter(gapminder, country == "Ireland")
```

І тут я одразу хочу познайомити вас з альтернативним варіантом запису коду в синтаксисі tidyverse. Справа в тому, що якщо послідовно використовувати низку різноманітних функцій, то читаймість такого коду стає дуже низькою. Покажу на прикладі:

1. До кожного значення вектора від 1 до 10 з кроком 1 розрахуємо сінус.

2. З отриманого на першому кроці візьмемо абсолютні значення.

3. З отриманого результату на 2 кроці візьмемо корінь квадратний

4. Відсортуємо результат.

В класичному вигляді все виглядає наступним чином:
```{r pipe01}
sort(sqrt(abs(sin(1:10))))
```

Погодьтесь, що розібрати такий код досить складно. Тому в діалекті tidyverse використовуються пайпи, `%>%`, (pipe) --- вони передають результат попереднього розрахунку першим аргументов наступної функції. Таким чином попередній код можна переписати наступним чином:
```{r pipe02}
1:10 %>% 
  sin() %>% 
  abs() %>% 
  sqrt() %>% 
  sort()
```

Погодьтесь, що такий код читається значно легше. Для виклику оператора `%>%` в RStudio використовується комбінація клавіш CTRL + SHIFT + M для Windows і CMD + SHIFT + M для Mac.

Тож, якщо повернутися до фільтрації \@ref(filter), код можна переписати:
```{r filter02}
# Попередній варіант
filter(gapminder, country == "Ireland")

# З використанням %>%
gapminder %>% 
  filter(country == "Ireland")
```
Тут і далі я буду часто використовувати пайпи.

Розберемо ще приклади фільтрації даних. Відберемо дані Ірландії та Іспанії за 2007 рік:
```{r filter03}
gapminder %>% 
  filter(country == "Ireland" | country == "Spain",
         year == 2007)
```

А тепер припустимо, що нам потрібно відібрати інформацію не по двом, а по низці країн. Переліковувати їх всіх через `country == "Назва_країни"` буде дуже довго і не зручно. В таких випадках зручно використовувати оператор `%in%`. Давайте відберемо інформацію по Ірландії, Іспанії, Норвегії та Польщі за 2007 рік:
```{r filter04}
gapminder %>% 
  filter(country %in% c("Ireland", "Spain", "Norway", "Poland"),
         year == 2007)
```

Всі потрібні умови фільтрації можна переліковувати всередині функції `filter()` через кому.

### dplyr::slice() {#slice}
Для отримання зрізу даних, тобто тільки певних спостережень (перші, останні тощо) використовуються варіації функції `slice()`.

Перші п'ять спостережень:
```{r slice01}
gapminder %>% 
  slice(1:5)
```

Перші п'ять та десяте спостереження:
```{r slice02}
gapminder %>% 
  slice(1:5, 10)
```

Всі крім перших трьох:
```{r slice03}
gapminder %>% 
  slice(-(1:3))
```

Перші 15 спостережень:
```{r slice04}
gapminder %>% 
  slice_head(n = 15)
```

Останні 15 спостережень:
```{r slice05}
gapminder %>% 
  slice_tail(n = 15)
```

Топ-3 з найбільшим значенням очікуваної тривалості життя:
```{r slice06}
gapminder %>% 
  slice_max(lifeExp, n = 3)
```

Топ-3 з найменшим значенням очікуваної тривалості життя:
```{r slice07}
gapminder %>% 
  slice_min(lifeExp, n = 3)
```

