# Маніпуляції з даними за допомогою dplyr {#dplyr}
***
```{r setup-02, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, collapse = TRUE, out.width = '100%')
```

В минулій главі ми розібрали основні принципи мови програмування R. І тут слід зазначити, що окрім базового синтаксису існують й інші. Загалом, можна виділити три основні діалекти в мові програмування R:

* base: основний фундамент мови, який ми розібрали (але не повністю) раніше.

* Tidyverse: окремий напрямок розвитку мови програмування R, що сконцентрований у напрямку науки про дані (data science).

* data.table: альтернативний напрямок, який дозволяє оброблювати об'ємні масиви даних за рекордний час @h2obench.

Їх можна сміло поєднувати в своїх проектах, що значним чином підвищує ефективність та швидкість роботи.

##  Tidy-всесвіт {#tidy}
***
[**Tidyverse**](https://www.tidyverse.org/) --- це екосистема, набір пакетів, які спеціально створені для науки про дані (data science). В ньому є ключові пакети (ядро tidyverse) та побічні --- які додатково розширюють можливості мови програмування R.

**Концепція охайних даних (tidy-data)** передбачає приведення даних до формату, в якому:

* Кожна змінна міститься в окремому стовпчику

* Кожне спостереження міститься в окремому рядку

* Кожне значення міститься в окремій комірці

**Ядро tidyverse:**

* *ggplot2*, для візуалізації

* *dplyr*, для маніпуляції з даними

* *tidyr*, для отримання охайних даних (tidy data)

* *readr*, для зчитування та записування файлів в R

* *purrr*, для функціонального програмування

* *tibble*, для роботи з тібблами (tibble), просунутий варіант дата фреймів

* *stringr*, для роботи з текстовими даними

* *forcats*, для роботи з факторами (factors)

Крім того є ще низка допоміжних пакетів, які не входять до ядра tidyverse але вважаються його частиною:

* *vroom*, для швидкого завантаження даних

* *DBI*, для роботи з базами даних

* *haven*, для даних SPSS, Stata та SAS

* *httr*, для роботи з API

* *readxl* для завантаження .xls та .xlsx файлів

* *googlesheets4*, для роботи з Google Sheet

* *googledrive*, для роботи з Google Drive

* *rvest*, для скрапінгу веб-сторінок

* *jsonlite*, для роботи з JSON-файлами

* *xml2*, для роботи з XML

* *lubridate*, для роботи з датами

* *dbplyr*, для перетворення коду `dplyr` в SQL

* *dtplyr*, для перетворення коду на `data.table`

* *magrittr*, для використання конвеєрів `%>%` (pipe)

* *glue*, для поєднання даних та тексту

* *tidymodels*, для роботи з моделями машнинного навчання.

І це ще не повний список. Крім офіційних пакетів tidyverse є ще низка пакетів, які намагаються відповідати принципам tidyverse і доповнюють його.

Головним чином, для роботи з даними, я зосереджу свою увагу на роботі з пакетом `dplyr`.

Для завантаження tidyverse необхідно виконати наступний код:
```{r tidyinstall, eval=FALSE}
install.packages("tidyverse")
```
Для підключення:
```{r tidyload, eval=FALSE}
library("tidyverse")
```

Концепція "охайних" даних передбачає альтернативу класичним `data.frame` у вигляді тібблів (`tibble`). Давайте розеберемо основі відмінності.
В мові програмування R є вбудований популярний датасет `iris`. Він зберігається в форматі дата фрейму.
```{r iris}
# Переглянемо перші декілька значень
head(iris)
```

Давайте створемо його альтернативу у вигляді тібблу:
```{r iristbl}
iris_tbl <- as_tibble(iris)
iris_tbl
```

Вже на цьому етапі видні основні відмінності: тіббл відображає одразу перші 10 спостережень і всі ствопчики, які поміщаються на екрані. Крім того до кожного стовпчика вказується його тип. Це дуже зручно, особливо коли працюєте з великим об'ємом даних.

## Завантаження даних {#tidy_read}
***
### Завантаження .csv, .tsv файлів {#tidy_csv}
Стандартною функцією завантаження даних типу `.csv` є функція `read.csv()`, але на досить великих масивах даних краще використовувати `read_csv()` з пакету `readr`. Синтаксис цих функцій схожий, але `read_csv()` одразу приведе дані до формату `tibble`.
Першим аргументом функції є шлях до файлу (із оберненим слешем `/`). Також можна використовувати прямі URL-посилання на файл: 
```{r eval=FALSE}
read_file <- read_csv("docs/data/file.csv")
read_url <- read_csv("https://git.io/JztOr")
```

Аналогічно до `read_csv()` можна використовувати функцію `vroom` з однойменного пакету. Головною особливістю цього пакету є [швидкість завантаження даних](https://cran.r-project.org/web/packages/vroom/vignettes/benchmarks.html).
```{r eval=FALSE}
vroom_file <- vroom("docs/data/file.csv")
vroom_url <- vroom("https://git.io/JztOr")
```

Для **завантаження** одночасно **декількох файлів однакової структури** корисно використовувати наступну конструкцію
```{r eval=FALSE}
filse <- dir(pattern = "\\.csv$")
vroom_all <- vroom(filse)
```

### Завантаження .xls, .xlsx файлів {#tidy_xls}
Для завантаження файлів **Excel** використовується пакет `readxl` та функція `read_excel()`.
На початку можна отримати перелік листів файлу Excel за допомогою функції `excel_sheets()`
```{r}
readxl::excel_sheets("docs/data/tourism.xlsx")
```
Після чого зчитати данні з потрібного листа
```{r eval=FALSE}
excel_file <- read_excel("docs/data/tourism.xlsx", sheet = "Sheet1")
```

В більшості випадків цього інструментарію має бути достатньо, але для завантаження специфічних файлів завжди можна знайти потрібний пакет. Не соромтеся використовувати google.


## Маніпуляції з даними за допомогою пакету dplyr {#dplyr}
***
dplyr - це граматика маніпуляції з даними, яка має низку функцій, які допоможуть легко та зручно маніпулювати даними, наприклад:

* створювати нові змінні

* сортувати дані

* проводити фільтрацію даних

* агрегування даних і багато іншого.

В якості прикладу роботи з пакетом dplyr пропоную використати датасет `gapminder` з однойменного пакету. В ньому збережена інформація про ВВП, очікувану тривалість життя при народженні та населення для 142 країн світу з 1952 по 2007 роки.
```{r gapminder}
# Підключаємо пакет (не забудьте його встановити) та подивимось на датасет
library(gapminder)
gapminder
```

Видно, що змінні `country` та `continent` --- це фактори, а всі інші --- числові.

### dplyr::glimpse() {#glimpse}
Для перегляду структури тібблу використовується функція `glimpse()`:
```{r glimpse}
glimpse(gapminder)
```
Це альтернатива базовій функції `str()` для дата фреймів.

### dplyr::filter() {#filter}
Для фільтрації спостережень за певною умовою використовується функція `filter()`. Для прикладу відфільтруємо дані для Ірландії:
```{r filter01}
filter(gapminder, country == "Ireland")
```

І тут я одразу хочу познайомити вас з альтернативним варіантом запису коду в синтаксисі tidyverse. Справа в тому, що якщо послідовно використовувати низку різноманітних функцій, то читаймість такого коду стає дуже низькою. Покажу на прикладі:

1. До кожного значення вектора від 1 до 10 з кроком 1 розрахуємо сінус.

2. З отриманого на першому кроці візьмемо абсолютні значення.

3. З отриманого результату на 2 кроці візьмемо корінь квадратний

4. Відсортуємо результат.

В класичному вигляді все виглядає наступним чином:
```{r pipe01}
sort(sqrt(abs(sin(1:10))))
```

Погодьтесь, що розібрати такий код досить складно. Тому в діалекті tidyverse використовуються пайпи, `%>%`, (pipe) --- вони передають результат попереднього розрахунку першим аргументов наступної функції. Таким чином попередній код можна переписати наступним чином:
```{r pipe02}
1:10 %>% 
  sin() %>% 
  abs() %>% 
  sqrt() %>% 
  sort()
```

Погодьтесь, що такий код читається значно легше. Для виклику оператора `%>%` в RStudio використовується комбінація клавіш CTRL + SHIFT + M для Windows і CMD + SHIFT + M для Mac.

Тож, якщо повернутися до фільтрації \@ref(filter), код можна переписати:
```{r filter02}
# Попередній варіант
filter(gapminder, country == "Ireland")

# З використанням %>%
gapminder %>% 
  filter(country == "Ireland")
```
Тут і далі я буду часто використовувати пайпи.

Розберемо ще приклади фільтрації даних. Відберемо дані Ірландії та Іспанії за 2007 рік:
```{r filter03}
gapminder %>% 
  filter(country == "Ireland" | country == "Spain",
         year == 2007)
```

А тепер припустимо, що нам потрібно відібрати інформацію не по двом, а по низці країн. Переліковувати їх всіх через `country == "Назва_країни"` буде дуже довго і не зручно. В таких випадках зручно використовувати оператор `%in%`. Давайте відберемо інформацію по Ірландії, Іспанії, Норвегії та Польщі за 2007 рік:
```{r filter04}
gapminder %>% 
  filter(country %in% c("Ireland", "Spain", "Norway", "Poland"),
         year == 2007)
```

Всі потрібні умови фільтрації можна переліковувати всередині функції `filter()` через кому.

### dplyr::slice() {#slice}
Для отримання зрізу даних, тобто тільки певних спостережень (перші, останні тощо) використовуються варіації функції `slice()`.

Перші п'ять спостережень:
```{r slice01}
gapminder %>% 
  slice(1:5)
```

Перші п'ять та десяте спостереження:
```{r slice02}
gapminder %>% 
  slice(1:5, 10)
```

Всі крім перших трьох:
```{r slice03}
gapminder %>% 
  slice(-(1:3))
```

Перші 15 спостережень:
```{r slice04}
gapminder %>% 
  slice_head(n = 15)
```

Останні 15 спостережень:
```{r slice05}
gapminder %>% 
  slice_tail(n = 15)
```

Топ-3 з найбільшим значенням очікуваної тривалості життя:
```{r slice06}
gapminder %>% 
  slice_max(lifeExp, n = 3)
```

Топ-3 з найменшим значенням очікуваної тривалості життя:
```{r slice07}
gapminder %>% 
  slice_min(lifeExp, n = 3)
```

Проста випадкова вибірка без повернення з трьох країн:
```{r slice08}
gapminder %>% 
  slice_sample(n = 3)
```

Зверніть увагу, що при повторному виконанні попереднього коду ви будете отримувати кожного разу різні підвибірки. Для того щоб отримати відтворюваний результат, необхідно вказати початкове значення генератора випадкових чисел за допомогою функції `set.seed()`. Аргументом цієї функції може бути будь-яке ціле число.
```{r slice09}
set.seed(2022)
gapminder %>% 
  slice_sample(n = 3)
```

Для формування простої випадкової вибірки з поверненням з трьох країн, необхідно додати аргумент `replace = TRUE`:
```{r slice10}
gapminder %>% 
  slice_sample(n = 3, replace = TRUE)
```

### dplyr::arrange() {#arrange}
Для впорядкування даних використовується функція `arrange()`. За замовчуванням сортування даних відбувається за зростанням.
Сортування по змінній ВВП на душу населення:
```{r arrange01}
gapminder %>% 
  arrange(gdpPercap)
```

Для того щоб сотувати дані за спаданням, використовується додаткова функція `desc()` в середині `arrange()`:
```{r arrange02}
gapminder %>% 
  arrange(desc(gdpPercap))
```

Якщо сортування за спаданням виконується по одній змінній, замість `desc()` можна використати знак `-`:
```{r}
# Але працює це тільки у випадку використання однієї змінної!
gapminder %>% 
  arrange(-gdpPercap)
```

### dplyr::select() {#select}
У випадках, коли змінних у данних дуже багато, є сенс відібрати тільки ті, з якими ви будете працювати. В таких випадках нам допоможе функція `select()`, хоча тільки такими задачами вона не обмежується.
У нашому випадку в наборі даних лише шість змінних, що в принципі небагато, але суть функції буде зрозуміла.
Відберемо, наприклад змінні по країнам та населенню:
```{r select01}
gapminder %>% 
  select(country, pop)
```

Через двокрапку можна вказати послідовність з декількох стовпчиків для відбору:
```{r select02}
gapminder %>% 
  select(country, lifeExp:gdpPercap)
```

Замість назв можна використовувати порядковий номер стовпчика (нагадую, що індексація в R починається з 1):
```{r select03}
gapminder %>% 
  select(1, 4:6)
```

Коли змінних дійсно багато, простіше вказати змінні, які хочеться викинути. Для цього використовується знак `-` (для відкидання однієї змінної) і `!` (для декількох, які необхідно помістити у вектор). Відкинемо змінну континенту:
```{r select04}
# Відкидаємо одну змінну за допомогою `-`
gapminder %>% 
  select(-continent)
```

Відкинемо змінну континенту та населення:
```{r select05}
# Відкидаємо декілька змінних за допомогою `!`
gapminder %>% 
  select(!c(continent, pop))
```

Крім того, за допомогою функцій `starts_with()`, `ends_with()`, `contains()` та `matches()` ми можемо задавати специфічні умови відбору змінних.
Для відбору стовпчиків, які починаються на певний вираз використовується `starts_with()`. Відберемо змінні, які починаються на **_co_**:
```{r select06}
gapminder %>% 
  select(starts_with("c"))
```

Змінні, які закінчуються на англійську літеру **_p_**:
```{r select07}
gapminder %>% 
  select(ends_with("p"))
```

Змінні, які містять англійську літеру **_x_**:
```{r select08}
gapminder %>% 
  select(contains("x"))
```

При роботі з даними часто використовуються [регулярні вирази](https://en.wikipedia.org/wiki/Regular_expression) (*regular expression*). Це певні патерни тексту, які відповідають певній умові. Ми можемо використовувати їх при відборі змінних за допомогою функції `matches()`.
Наприклад відберемо стовпчики, які в назві містять літери **_op_** або **_ap_**:
```{r select09}
gapminder %>% 
  select(matches("[oa]p"))
```

Для більш детального ознайомлення з цією темою рекомендую роботу @friedl2006.

За допомогою функції `where()` можна обирати змінні за їх типом. Наприклад відберемо факторні змінні:
```{r select10}
# Зверніть увагу, що умова "is.factor" 
# вживається без дужок в середині where()
gapminder %>% 
  select(where(is.factor))
```

Або залишимо тільки числові змінні:
```{r select11}
gapminder %>% 
  select(where(is.numeric))
```

Але і це ще не все: за допомогою функції `select()` та `everything()` можна змінювати позиції змінних у наборі даних. Спочатку ми вказуємо змінні, які хочемо помістити першими, після чого пишемо `everything()`. Наприклад, помістимо всі числові змінні на початку:
```{r select12}
gapminder %>% 
  select(where(is.numeric), everything())
```

### dplyr::relocate() {#relocate}
Насправді в dplyr є окрема функція для гнучкої зміни позиції --- `relocate()`. За замовчуванням вона поміщає вказані змінні на перші позиції:
```{r relocate01}
gapminder %>% 
  relocate(pop)
```

У функції `relocate()` є два додаткових аргументи: `.before()` та `.after()`. Вони використовуються для вказування місця зміни позиції стовпчика:
```{r relocate02}
# Помістимо стовпчик continent після year
gapminder %>% 
  relocate(continent, .after = year)

# Помістимо стовпчик continent після year
gapminder %>% 
  relocate(lifeExp, .before = gdpPercap)
```

Можна переміщати й одразу цілі групи:
```{r relocate03}
# Помістимо всі цілочислові змінні після факторних
gapminder %>% 
  relocate(where(is.integer), .after = where(is.factor))

# Помістимо всі факторні змінні після числових
gapminder %>% 
  relocate(where(is.numeric), .before = where(is.factor))
```

### dplyr::rename() {#rename}
Настав час ознайомитися, як змінювати назви стовпчиків. І в цьому нам допоможе функція `rename()`.
Змінємо назву стовпчика `pop` на `population`:
```{r rename01}
# Спочатку вказуємо нову назву, а після стару
gapminder %>% 
  rename(population = pop)
```

Можна змінювати регістр назв за допомогою функцій `rename_with()` та `toupper()` для запису великими літерами або `tolower()` для запису маленькими.

Запишемо всі назви великими:
```{r rename02}
gapminder %>% 
  rename_with(toupper)
```

Згадуючи попередні розділи, можемо враховувати специфічні патерни:
```{r rename03}
gapminder %>% 
  rename_with(toupper, ends_with("p"))
```

В роботі досить часто постає питання заміни певної частини назви. Наприклад, прибрати пробіли або замінити їх певний символ. Оскільки в нашому прикладі з назвами все більш-менш нормально, я спеціально вставлю пробіли перед великими літерами в назвах стовпчиків. В цьому випадку нам знову приходять на допомогу регулярні вирази. Результат я збережу у змінній `gapminder_rename`:
```{r rename04}
gapminder_rename <- gapminder %>% 
  rename_with(~ gsub("([a-z])([A-Z])","\\1 \\2", .x))

gapminder_rename
```

Використання стовпчиків в назвах яких зустрічаються пробіли незручно. Тому давайте виправимо цю ситуацію. Покажу декілька варіантів. Перший варіант з використанням базової функції `gsub()`, де першим аргументом ми вказуємо спочатку що змінюємо, а другим - на що змінюємо.
Замінимо пробіли в назвах стовпчиків на знак підкреслення ("_"):
```{r rename05}
# Знак "тільда" (~) в R використовуються в якості формули,
# ми познайомимось з її використанням в наступних темах
gapminder_rename %>% 
  rename_with(~ gsub(" ", "_", .x))
```

Другий варіант варіант ближчий до синтаксису tidyverse і використовує функції з пакету `stringr`, який створений для роботи з текстом:
```{r rename06}
gapminder_rename %>% 
    set_names(names(.) %>% str_replace(" ", "_") %>% str_to_title())
```

### dplyr::mutate() {#mutate}
Майже жодна маніпуляція з даними не обходиться без створення нових стовпчиків. Для цього використовується функція `mutate()`. За замовчуванням нова змінна записується в кінці набору даних.
Давайте розрахуємо загальний ВВП кожної країни в певний момент часу. Для цього створимо нову змінну `gdp_billion` в якій перемножимо змінні "кількість населення" на "ВВП на душу населення" та поділимо на один мільярд:
```{r mutate01}
gapminder %>% 
  mutate(gdp_billion = pop * gdpPercap / 10^9)
```

За допомогою аргументів `.before` та `.after` можна змінювати й позицію запису нової змінної:
```{r mutate02}
gapminder %>% 
  mutate(gdp_billion = pop * gdpPercap / 10^9,
         .after = year)
```

Інколи необхідно свторити стовпчик індексів: порядковий номер спостереження. Для цього можна використати функцію `row_number()`:
```{r mutate03}
gapminder %>% 
  mutate(record = row_number(),
         .before = country)
```

Або використати базовий синтаксис R:
```{r mutate04}
gapminder %>% 
  mutate(record = seq(1:n()),
         .before = country)
```

Якщо ж хочется залишити лише розрахунковий стовпчик --- використовується функція `transmute()`. При цьому вона дає можливість залишити й певні стовпчики з оригінального набору даних.

Залишимо змінну `country` та розрахуємо загальний ВВП:
```{r mutate05}
gapminder %>% 
  transmute(country,
            gdp_billion = pop * gdpPercap / 10^9)
```


bookdown::render_book("index.Rmd", output_dir = "docs")










