[{"path":"index.html","id":"основи-економетрики-в-r","chapter":"Основи економетрики в R","heading":"Основи економетрики в R","text":"","code":""},{"path":"index.html","id":"передмова","chapter":"Основи економетрики в R","heading":"Передмова","text":"Наразі підручник в процесі розробки.Якщо ви помітили неточності або помилки, будь-ласка напишіть мені: ihor.miroshnychenko@kneu.ua","code":""},{"path":"introR.html","id":"introR","chapter":" 1 Вступ до R","heading":" 1 Вступ до R","text":"Мова програмування R — потужний інструмент, що широко використовується в різних сферах: статистика, візуалізація, наука про дані, машинне навчання, глибоке навчання тощо. Це безкоштовна система з відкритим кодом, з широкими можливостями, які досягаються за рахунок різноманіття покетів (packages) доповнень.\nR повністю безкоштовний та доступний для встановлення на більшість операційних систем. Крім того, є можливість працювати у хмарних додатках.\nВ той же час, R ідеально підходить для проведення економетричних досліджень.\nВивчити R не складно і цей розділ підготовить Вас до базових операцій.","code":""},{"path":"introR.html","id":"installR","chapter":" 1 Вступ до R","heading":"1.1 Встановлення R","text":"Варіантів роботи з мовою програмування R існує досить багато. Розберемо основні.","code":""},{"path":"introR.html","id":"instalpc","chapter":" 1 Вступ до R","heading":"1.1.1 Встановлення на комп’ютер","text":"Для початку необхідно встановити саму мову програмування під свою операційну систему:WindowsMacOSLinuxДля роботи в R, також слів встановити інтегроване середовище розробки (IDE) RStudio, що значно підвищує зручність, швидкість та ефективність роботи.Щоб встановити RStudio, завантажте останню версію інсталятора для Вашої операційної системи з сайту https://rstudio.com/products/rstudio/download/","code":""},{"path":"introR.html","id":"installcloud","chapter":" 1 Вступ до R","heading":"1.1.2 Використання хмарних сервісів","text":"У випадках, коли не має можливості або бажання щось додатково встановлювати на ПК є декілька хмарних сервісів:RStudio CloudGoogle Colab","code":""},{"path":"introR.html","id":"rsudio","chapter":" 1 Вступ до R","heading":"1.2 RStudio","text":"Я пропоную використовувати саме RStudio, оскільки це найзручніший інструмент для роботи з даними.\nПри чому в ній можна працювати з різними мовами програмування, в тому числі й Python.Якщо ваша операційна система — Windows, то після встановлення R та RStudio, на робочому столі у вас буде дві іконки:Перша відноситься до самої мови програмування і не буде використовуватись в роботі, друга відноситься до RStudio і саме вона нам потрібна.\nРисунок 1.1: Базовий інтерфейс RStudio\nЯк правило код пишуть у скрипті (такий собі аналог текстового редактора), тож для його створення необхідно натиснути зелений хрестик в лівому верхньому куті та обрати пункт R Script або натиснути комбінацію клавіш Ctrl+Shift+N:\nРисунок 1.2: Створення скрипта в RStudio\nПісля чого, з’явиться додаткове вікно скрипту, де можна писати код, зберігати його та повертатися до нього за потреби.\nРисунок 1.3: Інтерфейс RStudio\n1. СКРИПТ — відбувається основна робота з кодом.2. КОНСОЛЬ — повертаються результати виконання скриптів. Хоча тут так само писати код, проте він не буде збережений.3. РОБОЧИЙ ПРОСТІР — тут зберігаються змінні, завантажені датасети та побудовані моделі. Крім того є окреме вкладинка історії останніх команд.4. ГРАФІКИ та ФАЙЛИ — тут в окремих закладинках відображаються графіки, є невеличкий файловий менеджер, менеджер пакетів (про них трошки пізніше) та довідка по функціям (сюди будемо звертатися досить часто).","code":""},{"path":"introR.html","id":"rbase","chapter":" 1 Вступ до R","heading":"1.3 Базові операції","text":"R - мова програмування з широкими можливостями. З її допомогою можна будувати математичні моделі, проводити статистичні тести, візуалізовувати дані тощо. Але почнемо з чогось максимально простого, наприклад, арифметики.","code":""},{"path":"introR.html","id":"rarith","chapter":" 1 Вступ до R","heading":"1.3.1 R та арифметика","text":"Вже з “коробки,” без додаткових пакетів, R надає можливість проводити арифметичні розрахунки. Всі ці операції виконуються за допомогою типових операторів, до яких ми звикли ще з часів навчання в школі або викорситання Excel.Так, додавання додавання двох чисел використовується оператор +:Для віднімання — оператор -:Множення через оператор *:Ділення — /:Піднесення до степеню через ^:Як бачимо, нічого складного. Давайте розглянемо, ще два оператори.Залишок від ділення — %%:Цілочисельне ділення — %/%:Узагальнений перелік арифметичних операторів я помістив у наступну таблицю.","code":"\n2 + 2\n## [1] 4\n5 - 2\n## [1] 3\n3 * 5\n## [1] 15\n25 / 5\n## [1] 5\n3 ^ 3 \n## [1] 27\n5 %% 3\n## [1] 2\n17 %/% 5\n## [1] 3"},{"path":"introR.html","id":"rcomment","chapter":" 1 Вступ до R","heading":"1.3.2 Коментарі до коду","text":"Важливою складовою написання коду, окрім його зрозумілості та лаконічності, є коментарі, які допомагають оріентуватися, що відбувається в даному шматку коду.Для додавання коментарів використовується знак ришітки або, як його ще називають, діез — #. Все, що написано у рядку після # ігнорується R:Якщо необхідно “закоментувати” частину коду, тобто поставити # на початку кожного рядка, то для цього є комбінація клавіш Ctrl + Shift + C.","code":"\n# look at this awesome code\n2 + 2 - 3 + 1\n## [1] 2"},{"path":"introR.html","id":"rprior","chapter":" 1 Вступ до R","heading":"1.3.3 Пріоритети розрахунків","text":"Після знайомства з арифметикою в R постає логічне питання з приводу пріоритетів операторів. На справді тут все просто, пріоритети працюють як в математиці. Тож не забувайте правильно розставляти дужки.","code":"\n2 + 3 * 4\n## [1] 14\n\n(2 + 3) * 4\n## [1] 20"},{"path":"introR.html","id":"rfun","chapter":" 1 Вступ до R","heading":"1.3.4 Готові функції","text":"Крім звичайних арифметичних операторів в мові програмування R одразу вбудовано багато різноманітних функцій, в тому числі й математичних.Для розрахунку кореня квадратного з числа використовується функція sqrt(), яка може бути вам знайома, якщо ви користувалися англомовною версією Excel.Мова програмування R чутлива до регістру, тож варіанти Sqrt(9), SQRT(9) працювати не будуть.Разом з тим, в середині функції можна проводити математичні розрахунки:Функція abs() розраховує абсолютне значення:Розрахунок натурального логарифму через функцію log():Але це ще не все, оскільки для логарифму притаманно мати основу, то в таких випадках слід додати в середині дужок додатковий аргумент base =:Аргументи функцій можна змінювати місцями:Доречі не обов’язково писати назви аргументів функцій. Якщо ви впевнені в їх порядку запис може виглядати наступним чином:Взагалі використання функцій — важлива особливість мови програмування R. Ми можемо створювати власні функції, використовувати функції як аргументи інших функцій тощо.","code":"\n9^0.5\n## [1] 3\n\n9^(1/2)\n## [1] 3\n\nsqrt(9)\n## [1] 3\nsqrt((2 + 3) * 4)\n## [1] 4.472136\nabs(3 - 5)\n## [1] 2\nlog(15)\n## [1] 2.70805\nlog(x = 10, base = 3)\n## [1] 2.095903\nlog(base = 3, x = 10)\n## [1] 2.095903\nlog(10, 3)\n## [1] 2.095903"},{"path":"introR.html","id":"rhelp","chapter":" 1 Вступ до R","heading":"1.3.5 Вбудована документація","text":"Вже на цьому етапі може виникнути ряд питань:де знайти опис функції?які існують аргументи функцій?чи є якісь приклади використання функцій?Відповідь досить проста — всі функції супроводжуються детальною документацією. Для її виклику можна скористуватися функцією help(), де в середині дужок вказати назву функції:Інший варіант — це написати в консолі знак питання і після цього назву функції:Але на мою думку, найшвидший варіант — це написати функцію і натиснути клавішу F1 на клавіатурі.Всі зазначені варіанти приведуть вас до вікна документації у правому нижньому куті RStudio:","code":"\nhelp(abs)\n?abs()"},{"path":"introR.html","id":"rvar","chapter":" 1 Вступ до R","heading":"1.3.6 Створення змінних","text":"Ще один важливий пункт у багатьох мовах програмування — можливість зберігати значення у змінних.В R це робиться за допомогою символів <-. Для швидкого написання існує зручна комбінація клавіш Alt + -.Ліворуч від символу <- записується назва майбутньої змінної. Праворуч — значення або вираз, яке необхідно зберегти в цю змінну.Для присоювання можна використовувати і знак = але серед спільноти користувачів R це не прийнято.Слід звернути увагу, що при присвоюванні результат розрахунку не виводиться в консоль. Якщо ж хочеться переглянути результат слід використати функцію print() або просто звернутися до створеної змінної:","code":"\nx <- 2\ny <- 4\nz <- sqrt(x^2 + y^3)\nprint(z)\n## [1] 8.246211\n\nz\n## [1] 8.246211"},{"path":"introR.html","id":"rcompar","chapter":" 1 Вступ до R","heading":"1.3.7 Оператори порівняння","text":"В процесі роботи з даними, досить часто працюємо з задачами порівняння. Для вирішення таких питань в мові програмування R є зручні та зрозумілі оператори:Окремо зауважу, що для порівняння двох змінних використовується оператор з подвійним знаком дорівнює ==, а не з одним =. Це досить популярна помилка.","code":""},{"path":"introR.html","id":"rdatatype","chapter":" 1 Вступ до R","heading":"1.4 Типи даних","text":"Інформація зберігається в різних структурах даних. Це може бути число, текст, булева змінна тощо.Один з найпопулярніших варіантів збереження даних — це числовий формат. В мові програмування R для нього є окремий клас — numeric. При цьому існує три типи numeric:Цілі - integer.Дробові - double.Комплексні - complex.В більшості випадків R буде сам конвертувати числа в потрібний формат. Але якщо необхідно задати конкретний тип числа, то можна використати функції .integer(), .double() та .complex().В мові програмування R досить багато функцій, які починаються на ., які переводять об’єкт до конкретного класу. Іншими словами просить читати дані в середені дужок у відповідному форматі.Для створення цілочислового значення можна в кінці поставити символ L, щоб примусово оголосити число як integer:Функції, що починаються на . перевіряють, чи належить об’єкт до обраного класу.Для роботи з текстовими даними є клас character. Вони записуються в лапках, при цьому можна використовувати як подвійні \" так і одинарні '.Логічні (logical) данні - це тип даних які приймають лише значення TRUE або FALSE. Ми з ними вже зустрічалися коли використовували оператори порівняння.Для перевірки типу даних використовується функція class():","code":"\nis.integer(10)\n## [1] FALSE\n\nis.integer(10L)\n## [1] TRUE\nis.character(\"Ash nazg durbatulûk, ash nazg gimbatul,\n             ash nazg thrakatulûk, agh burzum-ishi krimpatul.\")\n## [1] TRUE\nclass(5)\n## [1] \"numeric\""},{"path":"introR.html","id":"r_str","chapter":" 1 Вступ до R","heading":"1.5 Структури даних","text":"\nРисунок 1.4: Структури даних R\n","code":""},{"path":"introR.html","id":"r_vec","chapter":" 1 Вступ до R","heading":"1.5.1 Вектор","text":"Почнемо з найпростішого. Вектор - це одновимірна послідовність елементів одного типу. Для створення вектору використовується функція c().Для створення послідовностей з кроком 1 зручно використовувати оператор :Для складніших послідовностей є вбудована функція seq() (не забувайте дивитися довідку по функціях)Крім того, можна задати не лише крок послідовності (аргумент =), а й довжину (аргумент length.=)Інша корисна функція rep() дозволяє створити вектор з повторюваними значеннями. Перший аргумент - значення яке слід повторювати, другий аргумент - скільки разів повторювати.При цьому і перший і другий аргумент може бути вектором:Крім того, можна об’єднувати вектори:В означенні вектора в мові програмування R сказано, що всі елементи вектори мають бути одного типу. Одразу хочеться перевірити, що буде, якщо ця умова не буде виконуватись. В більшості мов програмування ми б отримали помилку. Мова програмування R, при розбіжності типів, буде зводити все до “спільного знаменника,” тобто конвертувати дані за певними правилами - приведення типів (coercion).Виділяють два типи:неявне приведення типів (implicit coercion), коли все відбувається автоматично за вбудованими правилами.явне приведення типів (explicit coercion), коли ми самі вирішуємо до якого типу перевести дані, якщо це можливо.Приклад неявного приведення типів:TRUE перетворився в 1, а FALSE в 0.\nВ цьому випадку всі дані приведено до текстового типу:В R є своя ієрархія типів:\nNULL < raw < logical < integer < double < complex < character < list < expressionДля явного приведення типів даних використовується сімейство функцій, що починається на .:","code":"\nc(2, 4, 8, -2, -6, 0)\n## [1]  2  4  8 -2 -6  0\n\nc(\"два\", \"чотири\", \"шість\")\n## [1] \"два\"    \"чотири\" \"шість\"\n\nc(TRUE, TRUE, FALSE)\n## [1]  TRUE  TRUE FALSE\n-5:5\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n3:-2\n## [1]  3  2  1  0 -1 -2\nseq(1, 10, by = 2)\n## [1] 1 3 5 7 9\nseq(1, 10, length.out = 3)\n## [1]  1.0  5.5 10.0\nrep(3, 5)\n## [1] 3 3 3 3 3\nrep(1:3, 5)\n##  [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n\nrep(1:3, 1:3)\n## [1] 1 2 2 3 3 3\nv1 <- c(\"Say\", \"friend\")\n\nv2 <- c(\"and\", \"enter\")\n\nc(v1, v2)\n## [1] \"Say\"    \"friend\" \"and\"    \"enter\"\nc(TRUE, 2, FALSE)\n## [1] 1 2 0\n\n3 - TRUE\n## [1] 2\nc(TRUE, 2, \"Hello\")\n## [1] \"TRUE\"  \"2\"     \"Hello\"\nas.numeric(c(TRUE, 2, FALSE, FALSE))\n## [1] 1 2 0 0\n\nas.character(c(TRUE, 2, FALSE, FALSE))\n## [1] \"1\" \"2\" \"0\" \"0\""},{"path":"introR.html","id":"r_vec_oper","chapter":" 1 Вступ до R","heading":"1.5.1.1 Операції з векторами","text":"Всі арифметичні операції, що ми розглядали раніше, можна використовувати й до векторів однакової довжини:","code":"\nq <- 1:5\n\nw <- 2:6\n\nq + w\n## [1]  3  5  7  9 11\n\nq - w\n## [1] -1 -1 -1 -1 -1\n\nq * w\n## [1]  2  6 12 20 30\n\nq / w\n## [1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n\nw ^ q + q - w * q\n## [1]    1    5   55  609 7751\n\nsqrt(q)\n## [1] 1.000000 1.414214 1.732051 2.000000 2.236068"},{"path":"introR.html","id":"r_rec_rule","chapter":" 1 Вступ до R","heading":"1.5.1.2 Правило переписування","text":"Якщо вектори не однакової довжини й ми хочемо провести з ними певні операції, то в такому випадку спрацює правило переписування (recycling rule): якщо коротший вектор кратний довжині довшого, короткий буде повторюватися необхідну кількість разів.Операції з вектором та окремим значенням можна вважати окремим випадком рестайлінгу: окреме значення буде повторюватися необхідну кількість разів:Якщо коротший вектор не кратний довшому (наприклад, перший довжиною 2, а інший - 3), то R все одно порахує результат, але видасть попередження:","code":"\nq <- 1:2\nw <- 1:4\nq * w\n## [1] 1 4 3 8\nw * 2\n## [1] 2 4 6 8\nq + c(1, 5, 7)\n## Warning in q + c(1, 5, 7): longer object length is not a multiple of shorter\n## object length\n## [1] 2 7 8"},{"path":"introR.html","id":"r_vec_idx","chapter":" 1 Вступ до R","heading":"1.5.1.3 Індексація векторів","text":"Індексація - задача вибору окремого елемента структури даних. Для цього використовуються квадратні дужки [].Найпростіший варіант індексація по номеру, тобто порядкове значення елемента:Важливий факт - індексація в мові програмування R починається з 1.За допомогою індексації можна не лише звертатися до окремого елементу, а й заміняти його значення:Можна використовувати цілі вектори для індексації:Індексація зі знаком мінус видасть всі значення вектора крім обраних:","code":"\ne <- c(-5:-3, 2, 7, -6, 4:2)\ne[1]\n## [1] -5\n\ne[5]\n## [1] 7\ne[5] <- 15\ne[2:5]\n## [1] -4 -3  2 15\n\ne[6:1]\n## [1] -6 15  2 -3 -4 -5\ne[-1]\n## [1] -4 -3  2 15 -6  4  3  2\n\ne[c(-1, -5)]\n## [1] -4 -3  2 -6  4  3  2"},{"path":"introR.html","id":"r_matrix","chapter":" 1 Вступ до R","heading":"1.5.2 Матриці","text":"Матриця (matrix) — це двовимірний масив даних, в якому кожен елемент має однаковий тип (числовий, текстовий, логічний). Іншими словами, матриця - це двовимірний вектор, у якого є довжина та ширина.Створення матриці відбувається за допомогою функції matrix(), в якій слід вказати кількість рядків та стовпчиків:За замовчуванням значення матриці заповнюються по стовпчиках. Але це можна змінити за допомогою аргументу byrow = TRUEОскільки матриця — це двовимірний масив, то для індексації використовуються два індекси, що розділені комою: перший відповідає за рядок, другий за стовпчик.Якщо один з індексів залишити пустим — отримаємо всі значення рядка/стовпчика в залежності від того, який індекс ми не вказуємо.Аналогічно до вектора, за допомогою індексації можна переписувати частину матриці:","code":"\nmatrix(1:16, nrow = 4, ncol = 4)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    5    9   13\n## [2,]    2    6   10   14\n## [3,]    3    7   11   15\n## [4,]    4    8   12   16\nmatrix(1:16, nrow = 4, ncol = 4, byrow = TRUE)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]    9   10   11   12\n## [4,]   13   14   15   16\nmy_matrix <- matrix(1:16, nrow = 4, ncol = 4)\nmy_matrix\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    5    9   13\n## [2,]    2    6   10   14\n## [3,]    3    7   11   15\n## [4,]    4    8   12   16\n\nmy_matrix[2, 3]\n## [1] 10\n\nmy_matrix[1:2, 3:4]\n##      [,1] [,2]\n## [1,]    9   13\n## [2,]   10   14\nmy_matrix[, 1:2]\n##      [,1] [,2]\n## [1,]    1    5\n## [2,]    2    6\n## [3,]    3    7\n## [4,]    4    8\n\nmy_matrix[1:2, ]\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    5    9   13\n## [2,]    2    6   10   14\nmy_matrix[1:2, 3:4] <- 0\nmy_matrix\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    5    0    0\n## [2,]    2    6    0    0\n## [3,]    3    7   11   15\n## [4,]    4    8   12   16"},{"path":"introR.html","id":"r_array","chapter":" 1 Вступ до R","heading":"1.5.3 Масиви","text":"Масиви даних (array) — схожі на матриці, але мають понад два виміри. Створюються вони за допомогою функції array(), де слід вказати вектор, з якого буде створено масив, і його розмірність:","code":"\nmy_array <- array(1:16, c(4, 2, 2))\nmy_array\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    5\n## [2,]    2    6\n## [3,]    3    7\n## [4,]    4    8\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    9   13\n## [2,]   10   14\n## [3,]   11   15\n## [4,]   12   16"},{"path":"introR.html","id":"r_list","chapter":" 1 Вступ до R","heading":"1.5.4 Списки","text":"Списки — це впорядкований набір об’єктів. Я представляю собі списки, як блокнот, в якому на кожній сторінці зберігається інформація у певному форматі. Вони можуть зберігати різні дані, в тому числі вектори, матриці, дата фрейми й інші списки.Списки створюються за допомогою функції list():В цьому випадку vec, gendalf та my_matrix — назви елементів списку.Для звернення до елементів списку можна використовувати індекси або імена (через символ $). При зверненні через індекс необхідно використовувати подвійні квадратні дужки, наприклад:Списки досить часто використовуються в R, наприклад результати побудови математичних моделей, статистичних тестів зберігаються у вигляді списків. тож важливо вміти з ними працювати.","code":"\nmy_list <- list(vec = c(1:5),\n                gendalf = \"You shall not pass\",\n                my_matrix = matrix(1:4, ncol = 2))\nmy_list\n## $vec\n## [1] 1 2 3 4 5\n## \n## $gendalf\n## [1] \"You shall not pass\"\n## \n## $my_matrix\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\nmy_list[[2]]\n## [1] \"You shall not pass\"\n\nmy_list$gendalf\n## [1] \"You shall not pass\"\n\nmy_list[['gendalf']]\n## [1] \"You shall not pass\""},{"path":"introR.html","id":"r_dataframe","chapter":" 1 Вступ до R","heading":"1.5.5 Дата фрейми","text":"Нарешті ми перейшли до найголовнішого - дата фрейми (data frames). Саме з такою структурою даних працюють найчастіше. Головною особливістю їх є те, що різні стовпчики можуть містити різний тип даних (але їх довжина має бути однаковою).\nДля створення дата фрейму використовується функція data.frame().Переглянути структуру дата фрейму можна за допомогою функції str():В нашому випадку перший та другий стовпчик - текстові, третя - числова, четверта - логічна.Переглянути назви стовпців або надати їм нову назву можна за допомогою функції names().Індексація аналогічно до матриці та списків можлива через [] та знак $.Для перегляду дата фрейму в RStudio використовується функція View() або можна просто натиснути на назву змінної у розділі Environment. Ви побачите таблицю, дещо схожу на Excel або Google Spreadsheets.","code":"\nmy_df <- data.frame(name = c(\"Frodo\", \"Eowyn\", \"Legolas\", \"Arwen\"),\n                    sex = c(\"male\", \"female\", \"male\", \"female\"),\n                    age = c(51, 24, 2931, 2700),\n                    one_ring = c(TRUE, FALSE, FALSE, FALSE))\nmy_df\nstr(my_df)\n## 'data.frame':    4 obs. of  4 variables:\n##  $ name    : chr  \"Frodo\" \"Eowyn\" \"Legolas\" \"Arwen\"\n##  $ sex     : chr  \"male\" \"female\" \"male\" \"female\"\n##  $ age     : num  51 24 2931 2700\n##  $ one_ring: logi  TRUE FALSE FALSE FALSE\nnames(my_df)\n## [1] \"name\"     \"sex\"      \"age\"      \"one_ring\"\nmy_df$name\n## [1] \"Frodo\"   \"Eowyn\"   \"Legolas\" \"Arwen\"\n\nmy_df$name[2:3]\n## [1] \"Eowyn\"   \"Legolas\"\n\nmy_df[2,3]\n## [1] 24\n\nmy_df[2:3, \"name\"]\n## [1] \"Eowyn\"   \"Legolas\""},{"path":"introR.html","id":"r_factors","chapter":" 1 Вступ до R","heading":"1.5.6 Фактори","text":"Фактори (factor) - спеціальний клас даних для збереження номінативних (якісних) змінних. Це можуть бути групи клієнтів, стать, якість обслуговування тощо.Для створення таких змінних використовується функція factor():При цьому всередині факторів можна зберігати впорядковані номінативні дані. Для цього необхідно вказати аргумент ordered = TRUE:","code":"\nrace <- factor(\n  c(\"istari\", \"human\", \"human\",\n    \"elf\", \"dwarf\", \"hobbit\",\n    \"hobbit\", \"hobbit\", \"hobbit\"),\n  levels = c(\"istari\", \"human\", \"elf\", \"dwarf\", \"hobbit\")\n  )\n\nrace\n## [1] istari human  human  elf    dwarf  hobbit hobbit hobbit hobbit\n## Levels: istari human elf dwarf hobbit\nlotr_books <- factor(c(\"The Fellowship of the Ring\",\n                       \"The Return of the King\",\n                       \"The Two Towers\"),\n                     levels = c(\"The Fellowship of the Ring\",\n                                \"The Two Towers\",\n                                \"The Return of the King\"),\n                     ordered = TRUE)\n\nlotr_books\n## [1] The Fellowship of the Ring The Return of the King    \n## [3] The Two Towers            \n## 3 Levels: The Fellowship of the Ring < ... < The Return of the King"},{"path":"introR.html","id":"r_packages","chapter":" 1 Вступ до R","heading":"1.6 Пакети в R","text":"R - мова програмування з дуже широкими можливостями. Однак рано чи пізно ми почнемо стикатися з задачами, які потребуватимуть додаткових можливостей. Ці можливості можна розширити за допомогою додаткових пакетів (packages).В більшості випадків основним змістом пакетів є набір додаткових функцій, даних або нових структур даних.До найпопулярніших пакетів у сфері науки про дані (data science) можна віднести екосистему пакетів tidyverse, пакети data.table, mlr3 та ще багато-багато інших.","code":""},{"path":"introR.html","id":"r_base_packages","chapter":" 1 Вступ до R","heading":"1.6.1 Вбудовані пакети","text":"Разом з самою мовою програмування R поставляються пакети, які не потрібно встановлювати: основний base та декілька інших, такі як stats, utils, graphics та інші. Повний перелік можна переглянути за наступним кодом:","code":"\nrownames(installed.packages(priority = \"base\"))\n##  [1] \"base\"      \"compiler\"  \"datasets\"  \"graphics\"  \"grDevices\" \"grid\"     \n##  [7] \"methods\"   \"parallel\"  \"splines\"   \"stats\"     \"stats4\"    \"tcltk\"    \n## [13] \"tools\"     \"utils\""},{"path":"introR.html","id":"r_cran","chapter":" 1 Вступ до R","heading":"1.6.2 Встановлення пакетів з CRAN","text":"Пакети які пройшли перевірку зберігаються в Comprehensive R Archive Network (CRAN). Для перегляду кількості опублікованих пакетів на CRAN можна використати наступний код:І з кожним роком їх стає все більше:\n\nФункція install.packages() дозволяє звантажувати та встановлювати пакети з CRAN. Для прикладу встановимо пакет vroom, для зчитування файлів\nРисунок 1.5: Меню встановлення пакетів в RStudio\nАбо через кнопку в розділі Packages (рис. 1.6)\nРисунок 1.6: Кнопка встановлення пакетів\n\nРисунок 1.7: Меню встановлення пакетів\n","code":"\nnrow(available.packages())\n## [1] 18979\ninstall.packages(\"vroom\")"},{"path":"introR.html","id":"r_git","chapter":" 1 Вступ до R","heading":"1.6.3 Встановлення пакетів з GitHub","text":"Бувають випадки, коли автори пакетів не пройшли або не захотіли проходити перевірку через CRAN (насправді причин може бути безліч). В таких випадках пакет (який ви напевно знайшли через пошук в Google) скоріш за все буде зберігатися на репозиторію GitHub. Для таких випадків нам необхідно встановити пакет devtools та використати з нього функцію install_github(). Покажу на прикладі пакету xaringan, який я використовую для створення інтерактивних презентацій.Посилання yihui/xaringan — це адреса пакету в GitHub","code":"\ndevtools::install_github('yihui/xaringan')"},{"path":"introR.html","id":"r_lib","chapter":" 1 Вступ до R","heading":"1.6.4 Підключення пакетів","text":"Після завантаження пакета, для того щоб почати користуватися його функціоналом необхідно його підключити до поточної сесії. Для цього використовується функція library(). Назву пакету можна писати як в лапках так і без них.Як правило, підключення пакетів записується на початку скрипта, що дає можливість зрозуміти який інструментарій використовується в ньому.","code":"\nlibrary(vroom)"},{"path":"introR.html","id":"r_fun_call","chapter":" 1 Вступ до R","heading":"1.6.5 Виклик функції через ::","text":"У випадках, коли функцію з пакету буде використано вcього декілька разів, є сенс не підключати весь пакет, а завантажити тільки окрему його функцію. Для цього використовується спеціальний оператор ::, ліворуч від якого вказується назва пакету, а праворуч відповідна функція з обраного пакету.Крім того оператор :: корисний у випадках, коли в різних пакетах присутні функції з однаковою назвою. Наприклад в пакеті dplyr є функція filter(). Функція з такою ж назвою є в базовому пакеті stats, який використовується у зовсім інших задачах. В таких просто вкажіть з якого пакету ви хочете використати функцію:Пріоритет надається функціоналу пакету, який був підключений останній.","code":"\nvroom::vroom_example()\nstats::filter(1:10, rep(1,3))"},{"path":"dplyr.html","id":"dplyr","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","text":"В минулій главі ми розібрали основні принципи мови програмування R. І тут слід зазначити, що окрім базового синтаксису існують й інші. Загалом, можна виділити три основні діалекти в мові програмування R:base: основний фундамент мови, який ми розібрали (але не повністю) раніше.base: основний фундамент мови, який ми розібрали (але не повністю) раніше.Tidyverse: окремий напрямок розвитку мови програмування R, що сконцентрований у напрямку науки про дані (data science).Tidyverse: окремий напрямок розвитку мови програмування R, що сконцентрований у напрямку науки про дані (data science).data.table: альтернативний напрямок, який дозволяє оброблювати об’ємні масиви даних за рекордний час “Database-Like Ops Benchmark” (n.d.).data.table: альтернативний напрямок, який дозволяє оброблювати об’ємні масиви даних за рекордний час “Database-Like Ops Benchmark” (n.d.).Їх можна сміло поєднувати в своїх проектах, що значним чином підвищує ефективність та швидкість роботи.","code":""},{"path":"dplyr.html","id":"tidy","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.1 Tidy-всесвіт","text":"Tidyverse — це екосистема, набір пакетів, які спеціально створені для науки про дані (data science). В ньому є ключові пакети (ядро tidyverse) та побічні — які додатково розширюють можливості мови програмування R.Концепція охайних даних (tidy-data) передбачає приведення даних до формату, в якому:Кожна змінна міститься в окремому стовпчикуКожна змінна міститься в окремому стовпчикуКожне спостереження міститься в окремому рядкуКожне спостереження міститься в окремому рядкуКожне значення міститься в окремій комірціКожне значення міститься в окремій комірціЯдро tidyverse:ggplot2, для візуалізаціїggplot2, для візуалізаціїdplyr, для маніпуляції з данимиdplyr, для маніпуляції з данимиtidyr, для отримання охайних даних (tidy data)tidyr, для отримання охайних даних (tidy data)readr, для зчитування та записування файлів в Rreadr, для зчитування та записування файлів в Rpurrr, для функціонального програмуванняpurrr, для функціонального програмуванняtibble, для роботи з тібблами (tibble), просунутий варіант дата фреймівtibble, для роботи з тібблами (tibble), просунутий варіант дата фреймівstringr, для роботи з текстовими данимиstringr, для роботи з текстовими данимиforcats, для роботи з факторами (factors)forcats, для роботи з факторами (factors)Крім того є ще низка допоміжних пакетів, які не входять до ядра tidyverse але вважаються його частиною:vroom, для швидкого завантаження данихvroom, для швидкого завантаження данихDBI, для роботи з базами данихDBI, для роботи з базами данихhaven, для даних SPSS, Stata та SAShaven, для даних SPSS, Stata та SAShttr, для роботи з APIhttr, для роботи з APIreadxl для завантаження .xls та .xlsx файлівreadxl для завантаження .xls та .xlsx файлівgooglesheets4, для роботи з Google Sheetgooglesheets4, для роботи з Google Sheetgoogledrive, для роботи з Google Drivegoogledrive, для роботи з Google Drivervest, для скрапінгу веб-сторінокrvest, для скрапінгу веб-сторінокjsonlite, для роботи з JSON-файламиjsonlite, для роботи з JSON-файламиxml2, для роботи з XMLxml2, для роботи з XMLlubridate, для роботи з датамиlubridate, для роботи з датамиdbplyr, для перетворення коду dplyr в SQLdbplyr, для перетворення коду dplyr в SQLdtplyr, для перетворення коду на data.tabledtplyr, для перетворення коду на data.tablemagrittr, для використання конвеєрів %>% (pipe)magrittr, для використання конвеєрів %>% (pipe)glue, для поєднання даних та текстуglue, для поєднання даних та текстуtidymodels, для роботи з моделями машнинного навчання.tidymodels, для роботи з моделями машнинного навчання.І це ще не повний список. Крім офіційних пакетів tidyverse є ще низка пакетів, які намагаються відповідати принципам tidyverse і доповнюють його.Головним чином, для роботи з даними, я зосереджу свою увагу на роботі з пакетом dplyr.Для завантаження tidyverse необхідно виконати наступний код:Для підключення:Концепція “охайних” даних передбачає альтернативу класичним data.frame у вигляді тібблів (tibble). Давайте розеберемо основі відмінності.\nВ мові програмування R є вбудований популярний датасет iris. Він зберігається в форматі дата фрейму.Давайте створемо його альтернативу у вигляді тібблу:Вже на цьому етапі видні основні відмінності: тіббл відображає одразу перші 10 спостережень і всі ствопчики, які поміщаються на екрані. Крім того до кожного стовпчика вказується його тип. Це дуже зручно, особливо коли працюєте з великим об’ємом даних.","code":"\ninstall.packages(\"tidyverse\")\nlibrary(\"tidyverse\")\n# Переглянемо перші декілька значень\nhead(iris)\n##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\n## 6          5.4         3.9          1.7         0.4  setosa\niris_tbl <- as_tibble(iris)\niris_tbl\n## # A tibble: 150 x 5\n##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n##  1          5.1         3.5          1.4         0.2 setosa \n##  2          4.9         3            1.4         0.2 setosa \n##  3          4.7         3.2          1.3         0.2 setosa \n##  4          4.6         3.1          1.5         0.2 setosa \n##  5          5           3.6          1.4         0.2 setosa \n##  6          5.4         3.9          1.7         0.4 setosa \n##  7          4.6         3.4          1.4         0.3 setosa \n##  8          5           3.4          1.5         0.2 setosa \n##  9          4.4         2.9          1.4         0.2 setosa \n## 10          4.9         3.1          1.5         0.1 setosa \n## # ... with 140 more rows"},{"path":"dplyr.html","id":"tidy_read","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.2 Завантаження даних","text":"","code":""},{"path":"dplyr.html","id":"tidy_csv","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.2.1 Завантаження .csv, .tsv файлів","text":"Стандартною функцією завантаження даних типу .csv є функція read.csv(), але на досить великих масивах даних краще використовувати read_csv() з пакету readr. Синтаксис цих функцій схожий, але read_csv() одразу приведе дані до формату tibble.\nПершим аргументом функції є шлях до файлу (із оберненим слешем /). Також можна використовувати прямі URL-посилання на файл:Аналогічно до read_csv() можна використовувати функцію vroom з однойменного пакету. Головною особливістю цього пакету є швидкість завантаження даних.Для завантаження одночасно декількох файлів однакової структури корисно використовувати наступну конструкцію","code":"\nread_file <- read_csv(\"docs/data/file.csv\")\nread_url <- read_csv(\"https://git.io/JztOr\")\nvroom_file <- vroom(\"docs/data/file.csv\")\nvroom_url <- vroom(\"https://git.io/JztOr\")\nfilse <- dir(pattern = \"\\\\.csv$\")\nvroom_all <- vroom(filse)"},{"path":"dplyr.html","id":"tidy_xls","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.2.2 Завантаження .xls, .xlsx файлів","text":"Для завантаження файлів Excel використовується пакет readxl та функція read_excel().\nНа початку можна отримати перелік листів файлу Excel за допомогою функції excel_sheets()Після чого зчитати данні з потрібного листаВ більшості випадків цього інструментарію має бути достатньо, але для завантаження специфічних файлів завжди можна знайти потрібний пакет. Не соромтеся використовувати google.","code":"\nreadxl::excel_sheets(\"docs/data/tourism.xlsx\")\n## [1] \"Sheet1\" \"Sheet2\" \"Sheet3\"\nexcel_file <- read_excel(\"docs/data/tourism.xlsx\", sheet = \"Sheet1\")"},{"path":"dplyr.html","id":"dplyr","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3 Маніпуляції з даними за допомогою пакету dplyr","text":"dplyr - це граматика маніпуляції з даними, яка має низку функцій, які допоможуть легко та зручно маніпулювати даними, наприклад:створювати нові змінністворювати нові зміннісортувати данісортувати даніпроводити фільтрацію данихпроводити фільтрацію данихагрегування даних і багато іншого.агрегування даних і багато іншого.В якості прикладу роботи з пакетом dplyr пропоную використати датасет gapminder з однойменного пакету. В ньому збережена інформація про ВВП, очікувану тривалість життя при народженні та населення для 142 країн світу з 1952 по 2007 роки.Видно, що змінні country та continent — це фактори, а всі інші — числові.","code":"\n# Підключаємо пакет (не забудьте його встановити) та подивимось на датасет\nlibrary(gapminder)\ngapminder\n## # A tibble: 1,704 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows"},{"path":"dplyr.html","id":"glimpse","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.1 dplyr::glimpse()","text":"Для перегляду структури тібблу використовується функція glimpse():Це альтернатива базовій функції str() для дата фреймів.","code":"\nglimpse(gapminder)\n## Rows: 1,704\n## Columns: 6\n## $ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", ~\n## $ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, ~\n## $ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, ~\n## $ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8~\n## $ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12~\n## $ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, ~"},{"path":"dplyr.html","id":"filter","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.2 dplyr::filter()","text":"Для фільтрації спостережень за певною умовою використовується функція filter(). Для прикладу відфільтруємо дані для Ірландії:І тут я одразу хочу познайомити вас з альтернативним варіантом запису коду в синтаксисі tidyverse. Справа в тому, що якщо послідовно використовувати низку різноманітних функцій, то читаймість такого коду стає дуже низькою. Покажу на прикладі:До кожного значення вектора від 1 до 10 з кроком 1 розрахуємо сінус.До кожного значення вектора від 1 до 10 з кроком 1 розрахуємо сінус.З отриманого на першому кроці візьмемо абсолютні значення.З отриманого на першому кроці візьмемо абсолютні значення.З отриманого результату на 2 кроці візьмемо корінь квадратнийЗ отриманого результату на 2 кроці візьмемо корінь квадратнийВідсортуємо результат.Відсортуємо результат.В класичному вигляді все виглядає наступним чином:Погодьтесь, що розібрати такий код досить складно. Тому в діалекті tidyverse використовуються пайпи, %>%, (pipe) — вони передають результат попереднього розрахунку першим аргументов наступної функції. Таким чином попередній код можна переписати наступним чином:Погодьтесь, що такий код читається значно легше. Для виклику оператора %>% в RStudio використовується комбінація клавіш CTRL + SHIFT + M для Windows і CMD + SHIFT + M для Mac.Тож, якщо повернутися до фільтрації 2.3.2, код можна переписати:Тут і далі я буду часто використовувати пайпи.Розберемо ще приклади фільтрації даних. Відберемо дані Ірландії та Іспанії за 2007 рік:А тепер припустимо, що нам потрібно відібрати інформацію не по двом, а по низці країн. Переліковувати їх всіх через country == \"Назва_країни\" буде дуже довго і не зручно. В таких випадках зручно використовувати оператор %%. Давайте відберемо інформацію по Ірландії, Іспанії, Норвегії та Польщі за 2007 рік:Всі потрібні умови фільтрації можна переліковувати всередині функції filter() через кому.","code":"\nfilter(gapminder, country == \"Ireland\")\n## # A tibble: 12 x 6\n##    country continent  year lifeExp     pop gdpPercap\n##    <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Ireland Europe     1952    66.9 2952156     5210.\n##  2 Ireland Europe     1957    68.9 2878220     5599.\n##  3 Ireland Europe     1962    70.3 2830000     6632.\n##  4 Ireland Europe     1967    71.1 2900100     7656.\n##  5 Ireland Europe     1972    71.3 3024400     9531.\n##  6 Ireland Europe     1977    72.0 3271900    11151.\n##  7 Ireland Europe     1982    73.1 3480000    12618.\n##  8 Ireland Europe     1987    74.4 3539900    13873.\n##  9 Ireland Europe     1992    75.5 3557761    17559.\n## 10 Ireland Europe     1997    76.1 3667233    24522.\n## 11 Ireland Europe     2002    77.8 3879155    34077.\n## 12 Ireland Europe     2007    78.9 4109086    40676.\nsort(sqrt(abs(sin(1:10))))\n##  [1] 0.3756594 0.5285977 0.6419646 0.7375779 0.8105471 0.8699440 0.9173173\n##  [8] 0.9535709 0.9792468 0.9946649\n1:10 %>% \n  sin() %>% \n  abs() %>% \n  sqrt() %>% \n  sort()\n##  [1] 0.3756594 0.5285977 0.6419646 0.7375779 0.8105471 0.8699440 0.9173173\n##  [8] 0.9535709 0.9792468 0.9946649\n# Попередній варіант\nfilter(gapminder, country == \"Ireland\")\n## # A tibble: 12 x 6\n##    country continent  year lifeExp     pop gdpPercap\n##    <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Ireland Europe     1952    66.9 2952156     5210.\n##  2 Ireland Europe     1957    68.9 2878220     5599.\n##  3 Ireland Europe     1962    70.3 2830000     6632.\n##  4 Ireland Europe     1967    71.1 2900100     7656.\n##  5 Ireland Europe     1972    71.3 3024400     9531.\n##  6 Ireland Europe     1977    72.0 3271900    11151.\n##  7 Ireland Europe     1982    73.1 3480000    12618.\n##  8 Ireland Europe     1987    74.4 3539900    13873.\n##  9 Ireland Europe     1992    75.5 3557761    17559.\n## 10 Ireland Europe     1997    76.1 3667233    24522.\n## 11 Ireland Europe     2002    77.8 3879155    34077.\n## 12 Ireland Europe     2007    78.9 4109086    40676.\n\n# З використанням %>%\ngapminder %>% \n  filter(country == \"Ireland\")\n## # A tibble: 12 x 6\n##    country continent  year lifeExp     pop gdpPercap\n##    <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Ireland Europe     1952    66.9 2952156     5210.\n##  2 Ireland Europe     1957    68.9 2878220     5599.\n##  3 Ireland Europe     1962    70.3 2830000     6632.\n##  4 Ireland Europe     1967    71.1 2900100     7656.\n##  5 Ireland Europe     1972    71.3 3024400     9531.\n##  6 Ireland Europe     1977    72.0 3271900    11151.\n##  7 Ireland Europe     1982    73.1 3480000    12618.\n##  8 Ireland Europe     1987    74.4 3539900    13873.\n##  9 Ireland Europe     1992    75.5 3557761    17559.\n## 10 Ireland Europe     1997    76.1 3667233    24522.\n## 11 Ireland Europe     2002    77.8 3879155    34077.\n## 12 Ireland Europe     2007    78.9 4109086    40676.\ngapminder %>% \n  filter(country == \"Ireland\" | country == \"Spain\",\n         year == 2007)\n## # A tibble: 2 x 6\n##   country continent  year lifeExp      pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Ireland Europe     2007    78.9  4109086    40676.\n## 2 Spain   Europe     2007    80.9 40448191    28821.\ngapminder %>% \n  filter(country %in% c(\"Ireland\", \"Spain\", \"Norway\", \"Poland\"),\n         year == 2007)\n## # A tibble: 4 x 6\n##   country continent  year lifeExp      pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Ireland Europe     2007    78.9  4109086    40676.\n## 2 Norway  Europe     2007    80.2  4627926    49357.\n## 3 Poland  Europe     2007    75.6 38518241    15390.\n## 4 Spain   Europe     2007    80.9 40448191    28821."},{"path":"dplyr.html","id":"slice","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.3 dplyr::slice()","text":"Для отримання зрізу даних, тобто тільки певних спостережень (перші, останні тощо) використовуються варіації функції slice().Перші п’ять спостережень:Перші п’ять та десяте спостереження:Всі крім перших трьох:Перші 15 спостережень:Останні 15 спостережень:Топ-3 з найбільшим значенням очікуваної тривалості життя:Топ-3 з найменшим значенням очікуваної тривалості життя:Проста випадкова вибірка без повернення з трьох країн:Зверніть увагу, що при повторному виконанні попереднього коду ви будете отримувати кожного разу різні підвибірки. Для того щоб отримати відтворюваний результат, необхідно вказати початкове значення генератора випадкових чисел за допомогою функції set.seed(). Аргументом цієї функції може бути будь-яке ціле число.Для формування простої випадкової вибірки з поверненням з трьох країн, необхідно додати аргумент replace = TRUE:","code":"\ngapminder %>% \n  slice(1:5)\n## # A tibble: 5 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\ngapminder %>% \n  slice(1:5, 10)\n## # A tibble: 6 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\n## 6 Afghanistan Asia       1997    41.8 22227415      635.\ngapminder %>% \n  slice(-(1:3))\n## # A tibble: 1,701 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1967    34.0 11537966      836.\n##  2 Afghanistan Asia       1972    36.1 13079460      740.\n##  3 Afghanistan Asia       1977    38.4 14880372      786.\n##  4 Afghanistan Asia       1982    39.9 12881816      978.\n##  5 Afghanistan Asia       1987    40.8 13867957      852.\n##  6 Afghanistan Asia       1992    41.7 16317921      649.\n##  7 Afghanistan Asia       1997    41.8 22227415      635.\n##  8 Afghanistan Asia       2002    42.1 25268405      727.\n##  9 Afghanistan Asia       2007    43.8 31889923      975.\n## 10 Albania     Europe     1952    55.2  1282697     1601.\n## # ... with 1,691 more rows\ngapminder %>% \n  slice_head(n = 15)\n## # A tibble: 15 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## 11 Afghanistan Asia       2002    42.1 25268405      727.\n## 12 Afghanistan Asia       2007    43.8 31889923      975.\n## 13 Albania     Europe     1952    55.2  1282697     1601.\n## 14 Albania     Europe     1957    59.3  1476505     1942.\n## 15 Albania     Europe     1962    64.8  1728137     2313.\ngapminder %>% \n  slice_tail(n = 15)\n## # A tibble: 15 x 6\n##    country  continent  year lifeExp      pop gdpPercap\n##    <fct>    <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Zambia   Africa     1997    40.2  9417789     1071.\n##  2 Zambia   Africa     2002    39.2 10595811     1072.\n##  3 Zambia   Africa     2007    42.4 11746035     1271.\n##  4 Zimbabwe Africa     1952    48.5  3080907      407.\n##  5 Zimbabwe Africa     1957    50.5  3646340      519.\n##  6 Zimbabwe Africa     1962    52.4  4277736      527.\n##  7 Zimbabwe Africa     1967    54.0  4995432      570.\n##  8 Zimbabwe Africa     1972    55.6  5861135      799.\n##  9 Zimbabwe Africa     1977    57.7  6642107      686.\n## 10 Zimbabwe Africa     1982    60.4  7636524      789.\n## 11 Zimbabwe Africa     1987    62.4  9216418      706.\n## 12 Zimbabwe Africa     1992    60.4 10704340      693.\n## 13 Zimbabwe Africa     1997    46.8 11404948      792.\n## 14 Zimbabwe Africa     2002    40.0 11926563      672.\n## 15 Zimbabwe Africa     2007    43.5 12311143      470.\ngapminder %>% \n  slice_max(lifeExp, n = 3)\n## # A tibble: 3 x 6\n##   country          continent  year lifeExp       pop gdpPercap\n##   <fct>            <fct>     <int>   <dbl>     <int>     <dbl>\n## 1 Japan            Asia       2007    82.6 127467972    31656.\n## 2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n## 3 Japan            Asia       2002    82   127065841    28605.\ngapminder %>% \n  slice_min(lifeExp, n = 3)\n## # A tibble: 3 x 6\n##   country     continent  year lifeExp     pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Rwanda      Africa     1992    23.6 7290203      737.\n## 2 Afghanistan Asia       1952    28.8 8425333      779.\n## 3 Gambia      Africa     1952    30    284320      485.\ngapminder %>% \n  slice_sample(n = 3)\n## # A tibble: 3 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Serbia      Europe     1957    61.7  7271135     4981.\n## 2 Afghanistan Asia       1962    32.0 10267083      853.\n## 3 Italy       Europe     1967    71.1 52667100    10022.\nset.seed(2022)\ngapminder %>% \n  slice_sample(n = 3)\n## # A tibble: 3 x 6\n##   country   continent  year lifeExp      pop gdpPercap\n##   <fct>     <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Cambodia  Asia       2007    59.7 14131858     1714.\n## 2 Swaziland Africa     1982    55.6   649901     3895.\n## 3 Kenya     Africa     1982    58.8 17661452     1348.\ngapminder %>% \n  slice_sample(n = 3, replace = TRUE)\n## # A tibble: 3 x 6\n##   country continent  year lifeExp        pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>      <int>     <dbl>\n## 1 India   Asia       2007    64.7 1110396331     2452.\n## 2 Italy   Europe     1977    73.5   56059245    14256.\n## 3 India   Asia       1982    56.6  708000000      856."},{"path":"dplyr.html","id":"arrange","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.4 dplyr::arrange()","text":"Для впорядкування даних використовується функція arrange(). За замовчуванням сортування даних відбувається за зростанням.\nСортування по змінній ВВП на душу населення:Для того щоб сотувати дані за спаданням, використовується додаткова функція desc() в середині arrange():Якщо сортування за спаданням виконується по одній змінній, замість desc() можна використати знак -:","code":"\ngapminder %>% \n  arrange(gdpPercap)\n## # A tibble: 1,704 x 6\n##    country          continent  year lifeExp      pop gdpPercap\n##    <fct>            <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Congo, Dem. Rep. Africa     2002    45.0 55379852      241.\n##  2 Congo, Dem. Rep. Africa     2007    46.5 64606759      278.\n##  3 Lesotho          Africa     1952    42.1   748747      299.\n##  4 Guinea-Bissau    Africa     1952    32.5   580653      300.\n##  5 Congo, Dem. Rep. Africa     1997    42.6 47798986      312.\n##  6 Eritrea          Africa     1952    35.9  1438760      329.\n##  7 Myanmar          Asia       1952    36.3 20092996      331 \n##  8 Lesotho          Africa     1957    45.0   813338      336.\n##  9 Burundi          Africa     1952    39.0  2445618      339.\n## 10 Eritrea          Africa     1957    38.0  1542611      344.\n## # ... with 1,694 more rows\ngapminder %>% \n  arrange(desc(gdpPercap))\n## # A tibble: 1,704 x 6\n##    country   continent  year lifeExp     pop gdpPercap\n##    <fct>     <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Kuwait    Asia       1957    58.0  212846   113523.\n##  2 Kuwait    Asia       1972    67.7  841934   109348.\n##  3 Kuwait    Asia       1952    55.6  160000   108382.\n##  4 Kuwait    Asia       1962    60.5  358266    95458.\n##  5 Kuwait    Asia       1967    64.6  575003    80895.\n##  6 Kuwait    Asia       1977    69.3 1140357    59265.\n##  7 Norway    Europe     2007    80.2 4627926    49357.\n##  8 Kuwait    Asia       2007    77.6 2505559    47307.\n##  9 Singapore Asia       2007    80.0 4553009    47143.\n## 10 Norway    Europe     2002    79.0 4535591    44684.\n## # ... with 1,694 more rows\n# Але працює це тільки у випадку використання однієї змінної!\ngapminder %>% \n  arrange(-gdpPercap)\n## # A tibble: 1,704 x 6\n##    country   continent  year lifeExp     pop gdpPercap\n##    <fct>     <fct>     <int>   <dbl>   <int>     <dbl>\n##  1 Kuwait    Asia       1957    58.0  212846   113523.\n##  2 Kuwait    Asia       1972    67.7  841934   109348.\n##  3 Kuwait    Asia       1952    55.6  160000   108382.\n##  4 Kuwait    Asia       1962    60.5  358266    95458.\n##  5 Kuwait    Asia       1967    64.6  575003    80895.\n##  6 Kuwait    Asia       1977    69.3 1140357    59265.\n##  7 Norway    Europe     2007    80.2 4627926    49357.\n##  8 Kuwait    Asia       2007    77.6 2505559    47307.\n##  9 Singapore Asia       2007    80.0 4553009    47143.\n## 10 Norway    Europe     2002    79.0 4535591    44684.\n## # ... with 1,694 more rows"},{"path":"dplyr.html","id":"select","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.5 dplyr::select()","text":"У випадках, коли змінних у данних дуже багато, є сенс відібрати тільки ті, з якими ви будете працювати. В таких випадках нам допоможе функція select(), хоча тільки такими задачами вона не обмежується.\nУ нашому випадку в наборі даних лише шість змінних, що в принципі небагато, але суть функції буде зрозуміла.\nВідберемо, наприклад змінні по країнам та населенню:Через двокрапку можна вказати послідовність з декількох стовпчиків для відбору:Замість назв можна використовувати порядковий номер стовпчика (нагадую, що індексація в R починається з 1):Коли змінних дійсно багато, простіше вказати змінні, які хочеться викинути. Для цього використовується знак - (для відкидання однієї змінної) і ! (для декількох, які необхідно помістити у вектор). Відкинемо змінну континенту:Відкинемо змінну континенту та населення:Крім того, за допомогою функцій starts_with(), ends_with(), contains() та matches() ми можемо задавати специфічні умови відбору змінних.\nДля відбору стовпчиків, які починаються на певний вираз використовується starts_with(). Відберемо змінні, які починаються на co:Змінні, які закінчуються на англійську літеру p:Змінні, які містять англійську літеру x:При роботі з даними часто використовуються регулярні вирази (regular expression). Це певні патерни тексту, які відповідають певній умові. Ми можемо використовувати їх при відборі змінних за допомогою функції matches().\nНаприклад відберемо стовпчики, які в назві містять літери op або ap:Для більш детального ознайомлення з цією темою рекомендую роботу Friedl (2006).За допомогою функції () можна обирати змінні за їх типом. Наприклад відберемо факторні змінні:Або залишимо тільки числові змінні:Але і це ще не все: за допомогою функції select() та everything() можна змінювати позиції змінних у наборі даних. Спочатку ми вказуємо змінні, які хочемо помістити першими, після чого пишемо everything(). Наприклад, помістимо всі числові змінні на початку:","code":"\ngapminder %>% \n  select(country, pop)\n## # A tibble: 1,704 x 2\n##    country          pop\n##    <fct>          <int>\n##  1 Afghanistan  8425333\n##  2 Afghanistan  9240934\n##  3 Afghanistan 10267083\n##  4 Afghanistan 11537966\n##  5 Afghanistan 13079460\n##  6 Afghanistan 14880372\n##  7 Afghanistan 12881816\n##  8 Afghanistan 13867957\n##  9 Afghanistan 16317921\n## 10 Afghanistan 22227415\n## # ... with 1,694 more rows\ngapminder %>% \n  select(country, lifeExp:gdpPercap)\n## # A tibble: 1,704 x 4\n##    country     lifeExp      pop gdpPercap\n##    <fct>         <dbl>    <int>     <dbl>\n##  1 Afghanistan    28.8  8425333      779.\n##  2 Afghanistan    30.3  9240934      821.\n##  3 Afghanistan    32.0 10267083      853.\n##  4 Afghanistan    34.0 11537966      836.\n##  5 Afghanistan    36.1 13079460      740.\n##  6 Afghanistan    38.4 14880372      786.\n##  7 Afghanistan    39.9 12881816      978.\n##  8 Afghanistan    40.8 13867957      852.\n##  9 Afghanistan    41.7 16317921      649.\n## 10 Afghanistan    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  select(1, 4:6)\n## # A tibble: 1,704 x 4\n##    country     lifeExp      pop gdpPercap\n##    <fct>         <dbl>    <int>     <dbl>\n##  1 Afghanistan    28.8  8425333      779.\n##  2 Afghanistan    30.3  9240934      821.\n##  3 Afghanistan    32.0 10267083      853.\n##  4 Afghanistan    34.0 11537966      836.\n##  5 Afghanistan    36.1 13079460      740.\n##  6 Afghanistan    38.4 14880372      786.\n##  7 Afghanistan    39.9 12881816      978.\n##  8 Afghanistan    40.8 13867957      852.\n##  9 Afghanistan    41.7 16317921      649.\n## 10 Afghanistan    41.8 22227415      635.\n## # ... with 1,694 more rows\n# Відкидаємо одну змінну за допомогою `-`\ngapminder %>% \n  select(-continent)\n## # A tibble: 1,704 x 5\n##    country      year lifeExp      pop gdpPercap\n##    <fct>       <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan  1952    28.8  8425333      779.\n##  2 Afghanistan  1957    30.3  9240934      821.\n##  3 Afghanistan  1962    32.0 10267083      853.\n##  4 Afghanistan  1967    34.0 11537966      836.\n##  5 Afghanistan  1972    36.1 13079460      740.\n##  6 Afghanistan  1977    38.4 14880372      786.\n##  7 Afghanistan  1982    39.9 12881816      978.\n##  8 Afghanistan  1987    40.8 13867957      852.\n##  9 Afghanistan  1992    41.7 16317921      649.\n## 10 Afghanistan  1997    41.8 22227415      635.\n## # ... with 1,694 more rows\n# Відкидаємо декілька змінних за допомогою `!`\ngapminder %>% \n  select(!c(continent, pop))\n## # A tibble: 1,704 x 4\n##    country      year lifeExp gdpPercap\n##    <fct>       <int>   <dbl>     <dbl>\n##  1 Afghanistan  1952    28.8      779.\n##  2 Afghanistan  1957    30.3      821.\n##  3 Afghanistan  1962    32.0      853.\n##  4 Afghanistan  1967    34.0      836.\n##  5 Afghanistan  1972    36.1      740.\n##  6 Afghanistan  1977    38.4      786.\n##  7 Afghanistan  1982    39.9      978.\n##  8 Afghanistan  1987    40.8      852.\n##  9 Afghanistan  1992    41.7      649.\n## 10 Afghanistan  1997    41.8      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  select(starts_with(\"c\"))\n## # A tibble: 1,704 x 2\n##    country     continent\n##    <fct>       <fct>    \n##  1 Afghanistan Asia     \n##  2 Afghanistan Asia     \n##  3 Afghanistan Asia     \n##  4 Afghanistan Asia     \n##  5 Afghanistan Asia     \n##  6 Afghanistan Asia     \n##  7 Afghanistan Asia     \n##  8 Afghanistan Asia     \n##  9 Afghanistan Asia     \n## 10 Afghanistan Asia     \n## # ... with 1,694 more rows\ngapminder %>% \n  select(ends_with(\"p\"))\n## # A tibble: 1,704 x 3\n##    lifeExp      pop gdpPercap\n##      <dbl>    <int>     <dbl>\n##  1    28.8  8425333      779.\n##  2    30.3  9240934      821.\n##  3    32.0 10267083      853.\n##  4    34.0 11537966      836.\n##  5    36.1 13079460      740.\n##  6    38.4 14880372      786.\n##  7    39.9 12881816      978.\n##  8    40.8 13867957      852.\n##  9    41.7 16317921      649.\n## 10    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  select(contains(\"x\"))\n## # A tibble: 1,704 x 1\n##    lifeExp\n##      <dbl>\n##  1    28.8\n##  2    30.3\n##  3    32.0\n##  4    34.0\n##  5    36.1\n##  6    38.4\n##  7    39.9\n##  8    40.8\n##  9    41.7\n## 10    41.8\n## # ... with 1,694 more rows\ngapminder %>% \n  select(matches(\"[oa]p\"))\n## # A tibble: 1,704 x 2\n##         pop gdpPercap\n##       <int>     <dbl>\n##  1  8425333      779.\n##  2  9240934      821.\n##  3 10267083      853.\n##  4 11537966      836.\n##  5 13079460      740.\n##  6 14880372      786.\n##  7 12881816      978.\n##  8 13867957      852.\n##  9 16317921      649.\n## 10 22227415      635.\n## # ... with 1,694 more rows\n# Зверніть увагу, що умова \"is.factor\" \n# вживається без дужок в середині where()\ngapminder %>% \n  select(where(is.factor))\n## # A tibble: 1,704 x 2\n##    country     continent\n##    <fct>       <fct>    \n##  1 Afghanistan Asia     \n##  2 Afghanistan Asia     \n##  3 Afghanistan Asia     \n##  4 Afghanistan Asia     \n##  5 Afghanistan Asia     \n##  6 Afghanistan Asia     \n##  7 Afghanistan Asia     \n##  8 Afghanistan Asia     \n##  9 Afghanistan Asia     \n## 10 Afghanistan Asia     \n## # ... with 1,694 more rows\ngapminder %>% \n  select(where(is.numeric))\n## # A tibble: 1,704 x 4\n##     year lifeExp      pop gdpPercap\n##    <int>   <dbl>    <int>     <dbl>\n##  1  1952    28.8  8425333      779.\n##  2  1957    30.3  9240934      821.\n##  3  1962    32.0 10267083      853.\n##  4  1967    34.0 11537966      836.\n##  5  1972    36.1 13079460      740.\n##  6  1977    38.4 14880372      786.\n##  7  1982    39.9 12881816      978.\n##  8  1987    40.8 13867957      852.\n##  9  1992    41.7 16317921      649.\n## 10  1997    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  select(where(is.numeric), everything())\n## # A tibble: 1,704 x 6\n##     year lifeExp      pop gdpPercap country     continent\n##    <int>   <dbl>    <int>     <dbl> <fct>       <fct>    \n##  1  1952    28.8  8425333      779. Afghanistan Asia     \n##  2  1957    30.3  9240934      821. Afghanistan Asia     \n##  3  1962    32.0 10267083      853. Afghanistan Asia     \n##  4  1967    34.0 11537966      836. Afghanistan Asia     \n##  5  1972    36.1 13079460      740. Afghanistan Asia     \n##  6  1977    38.4 14880372      786. Afghanistan Asia     \n##  7  1982    39.9 12881816      978. Afghanistan Asia     \n##  8  1987    40.8 13867957      852. Afghanistan Asia     \n##  9  1992    41.7 16317921      649. Afghanistan Asia     \n## 10  1997    41.8 22227415      635. Afghanistan Asia     \n## # ... with 1,694 more rows"},{"path":"dplyr.html","id":"relocate","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.6 dplyr::relocate()","text":"Насправді в dplyr є окрема функція для гнучкої зміни позиції — relocate(). За замовчуванням вона поміщає вказані змінні на перші позиції:У функції relocate() є два додаткових аргументи: .() та .(). Вони використовуються для вказування місця зміни позиції стовпчика:Можна переміщати й одразу цілі групи:","code":"\ngapminder %>% \n  relocate(pop)\n## # A tibble: 1,704 x 6\n##         pop country     continent  year lifeExp gdpPercap\n##       <int> <fct>       <fct>     <int>   <dbl>     <dbl>\n##  1  8425333 Afghanistan Asia       1952    28.8      779.\n##  2  9240934 Afghanistan Asia       1957    30.3      821.\n##  3 10267083 Afghanistan Asia       1962    32.0      853.\n##  4 11537966 Afghanistan Asia       1967    34.0      836.\n##  5 13079460 Afghanistan Asia       1972    36.1      740.\n##  6 14880372 Afghanistan Asia       1977    38.4      786.\n##  7 12881816 Afghanistan Asia       1982    39.9      978.\n##  8 13867957 Afghanistan Asia       1987    40.8      852.\n##  9 16317921 Afghanistan Asia       1992    41.7      649.\n## 10 22227415 Afghanistan Asia       1997    41.8      635.\n## # ... with 1,694 more rows\n# Помістимо стовпчик continent після year\ngapminder %>% \n  relocate(continent, .after = year)\n## # A tibble: 1,704 x 6\n##    country      year continent lifeExp      pop gdpPercap\n##    <fct>       <int> <fct>       <dbl>    <int>     <dbl>\n##  1 Afghanistan  1952 Asia         28.8  8425333      779.\n##  2 Afghanistan  1957 Asia         30.3  9240934      821.\n##  3 Afghanistan  1962 Asia         32.0 10267083      853.\n##  4 Afghanistan  1967 Asia         34.0 11537966      836.\n##  5 Afghanistan  1972 Asia         36.1 13079460      740.\n##  6 Afghanistan  1977 Asia         38.4 14880372      786.\n##  7 Afghanistan  1982 Asia         39.9 12881816      978.\n##  8 Afghanistan  1987 Asia         40.8 13867957      852.\n##  9 Afghanistan  1992 Asia         41.7 16317921      649.\n## 10 Afghanistan  1997 Asia         41.8 22227415      635.\n## # ... with 1,694 more rows\n\n# Помістимо стовпчик continent після year\ngapminder %>% \n  relocate(lifeExp, .before = gdpPercap)\n## # A tibble: 1,704 x 6\n##    country     continent  year      pop lifeExp gdpPercap\n##    <fct>       <fct>     <int>    <int>   <dbl>     <dbl>\n##  1 Afghanistan Asia       1952  8425333    28.8      779.\n##  2 Afghanistan Asia       1957  9240934    30.3      821.\n##  3 Afghanistan Asia       1962 10267083    32.0      853.\n##  4 Afghanistan Asia       1967 11537966    34.0      836.\n##  5 Afghanistan Asia       1972 13079460    36.1      740.\n##  6 Afghanistan Asia       1977 14880372    38.4      786.\n##  7 Afghanistan Asia       1982 12881816    39.9      978.\n##  8 Afghanistan Asia       1987 13867957    40.8      852.\n##  9 Afghanistan Asia       1992 16317921    41.7      649.\n## 10 Afghanistan Asia       1997 22227415    41.8      635.\n## # ... with 1,694 more rows\n# Помістимо всі цілочислові змінні після факторних\ngapminder %>% \n  relocate(where(is.integer), .after = where(is.factor))\n## # A tibble: 1,704 x 6\n##    country     continent  year      pop lifeExp gdpPercap\n##    <fct>       <fct>     <int>    <int>   <dbl>     <dbl>\n##  1 Afghanistan Asia       1952  8425333    28.8      779.\n##  2 Afghanistan Asia       1957  9240934    30.3      821.\n##  3 Afghanistan Asia       1962 10267083    32.0      853.\n##  4 Afghanistan Asia       1967 11537966    34.0      836.\n##  5 Afghanistan Asia       1972 13079460    36.1      740.\n##  6 Afghanistan Asia       1977 14880372    38.4      786.\n##  7 Afghanistan Asia       1982 12881816    39.9      978.\n##  8 Afghanistan Asia       1987 13867957    40.8      852.\n##  9 Afghanistan Asia       1992 16317921    41.7      649.\n## 10 Afghanistan Asia       1997 22227415    41.8      635.\n## # ... with 1,694 more rows\n\n# Помістимо всі факторні змінні після числових\ngapminder %>% \n  relocate(where(is.numeric), .before = where(is.factor))\n## # A tibble: 1,704 x 6\n##     year lifeExp      pop gdpPercap country     continent\n##    <int>   <dbl>    <int>     <dbl> <fct>       <fct>    \n##  1  1952    28.8  8425333      779. Afghanistan Asia     \n##  2  1957    30.3  9240934      821. Afghanistan Asia     \n##  3  1962    32.0 10267083      853. Afghanistan Asia     \n##  4  1967    34.0 11537966      836. Afghanistan Asia     \n##  5  1972    36.1 13079460      740. Afghanistan Asia     \n##  6  1977    38.4 14880372      786. Afghanistan Asia     \n##  7  1982    39.9 12881816      978. Afghanistan Asia     \n##  8  1987    40.8 13867957      852. Afghanistan Asia     \n##  9  1992    41.7 16317921      649. Afghanistan Asia     \n## 10  1997    41.8 22227415      635. Afghanistan Asia     \n## # ... with 1,694 more rows"},{"path":"dplyr.html","id":"rename","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.7 dplyr::rename()","text":"Настав час ознайомитися, як змінювати назви стовпчиків. І в цьому нам допоможе функція rename().\nЗмінємо назву стовпчика pop на population:Можна змінювати регістр назв за допомогою функцій rename_with() та toupper() для запису великими літерами або tolower() для запису маленькими.Запишемо всі назви великими:Згадуючи попередні розділи, можемо враховувати специфічні патерни:В роботі досить часто постає питання заміни певної частини назви. Наприклад, прибрати пробіли або замінити їх певний символ. Оскільки в нашому прикладі з назвами все більш-менш нормально, я спеціально вставлю пробіли перед великими літерами в назвах стовпчиків. В цьому випадку нам знову приходять на допомогу регулярні вирази. Результат я збережу у змінній gapminder_rename:Використання стовпчиків в назвах яких зустрічаються пробіли незручно. Тому давайте виправимо цю ситуацію. Покажу декілька варіантів. Перший варіант з використанням базової функції gsub(), де першим аргументом ми вказуємо спочатку що змінюємо, а другим - на що змінюємо.\nЗамінимо пробіли в назвах стовпчиків на знак підкреслення (\"_\"):Другий варіант варіант ближчий до синтаксису tidyverse і використовує функції з пакету stringr, який створений для роботи з текстом:","code":"\n# Спочатку вказуємо нову назву, а після стару\ngapminder %>% \n  rename(population = pop)\n## # A tibble: 1,704 x 6\n##    country     continent  year lifeExp population gdpPercap\n##    <fct>       <fct>     <int>   <dbl>      <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8    8425333      779.\n##  2 Afghanistan Asia       1957    30.3    9240934      821.\n##  3 Afghanistan Asia       1962    32.0   10267083      853.\n##  4 Afghanistan Asia       1967    34.0   11537966      836.\n##  5 Afghanistan Asia       1972    36.1   13079460      740.\n##  6 Afghanistan Asia       1977    38.4   14880372      786.\n##  7 Afghanistan Asia       1982    39.9   12881816      978.\n##  8 Afghanistan Asia       1987    40.8   13867957      852.\n##  9 Afghanistan Asia       1992    41.7   16317921      649.\n## 10 Afghanistan Asia       1997    41.8   22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  rename_with(toupper)\n## # A tibble: 1,704 x 6\n##    COUNTRY     CONTINENT  YEAR LIFEEXP      POP GDPPERCAP\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  rename_with(toupper, ends_with(\"p\"))\n## # A tibble: 1,704 x 6\n##    country     continent  year LIFEEXP      POP GDPPERCAP\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder_rename <- gapminder %>% \n  rename_with(~ gsub(\"([a-z])([A-Z])\",\"\\\\1 \\\\2\", .x))\n\ngapminder_rename\n## # A tibble: 1,704 x 6\n##    country     continent  year `life Exp`      pop `gdp Percap`\n##    <fct>       <fct>     <int>      <dbl>    <int>        <dbl>\n##  1 Afghanistan Asia       1952       28.8  8425333         779.\n##  2 Afghanistan Asia       1957       30.3  9240934         821.\n##  3 Afghanistan Asia       1962       32.0 10267083         853.\n##  4 Afghanistan Asia       1967       34.0 11537966         836.\n##  5 Afghanistan Asia       1972       36.1 13079460         740.\n##  6 Afghanistan Asia       1977       38.4 14880372         786.\n##  7 Afghanistan Asia       1982       39.9 12881816         978.\n##  8 Afghanistan Asia       1987       40.8 13867957         852.\n##  9 Afghanistan Asia       1992       41.7 16317921         649.\n## 10 Afghanistan Asia       1997       41.8 22227415         635.\n## # ... with 1,694 more rows\n# Знак \"тільда\" (~) в R використовуються в якості формули,\n# ми познайомимось з її використанням в наступних темах\ngapminder_rename %>% \n  rename_with(~ gsub(\" \", \"_\", .x))\n## # A tibble: 1,704 x 6\n##    country     continent  year life_Exp      pop gdp_Percap\n##    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>\n##  1 Afghanistan Asia       1952     28.8  8425333       779.\n##  2 Afghanistan Asia       1957     30.3  9240934       821.\n##  3 Afghanistan Asia       1962     32.0 10267083       853.\n##  4 Afghanistan Asia       1967     34.0 11537966       836.\n##  5 Afghanistan Asia       1972     36.1 13079460       740.\n##  6 Afghanistan Asia       1977     38.4 14880372       786.\n##  7 Afghanistan Asia       1982     39.9 12881816       978.\n##  8 Afghanistan Asia       1987     40.8 13867957       852.\n##  9 Afghanistan Asia       1992     41.7 16317921       649.\n## 10 Afghanistan Asia       1997     41.8 22227415       635.\n## # ... with 1,694 more rows\ngapminder_rename %>% \n    set_names(names(.) %>% str_replace(\" \", \"_\") %>% str_to_title())\n## # A tibble: 1,704 x 6\n##    Country     Continent  Year Life_exp      Pop Gdp_percap\n##    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>\n##  1 Afghanistan Asia       1952     28.8  8425333       779.\n##  2 Afghanistan Asia       1957     30.3  9240934       821.\n##  3 Afghanistan Asia       1962     32.0 10267083       853.\n##  4 Afghanistan Asia       1967     34.0 11537966       836.\n##  5 Afghanistan Asia       1972     36.1 13079460       740.\n##  6 Afghanistan Asia       1977     38.4 14880372       786.\n##  7 Afghanistan Asia       1982     39.9 12881816       978.\n##  8 Afghanistan Asia       1987     40.8 13867957       852.\n##  9 Afghanistan Asia       1992     41.7 16317921       649.\n## 10 Afghanistan Asia       1997     41.8 22227415       635.\n## # ... with 1,694 more rows"},{"path":"dplyr.html","id":"mutate","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.8 dplyr::mutate()","text":"Майже жодна маніпуляція з даними не обходиться без створення нових стовпчиків. Для цього використовується функція mutate(). За замовчуванням нова змінна записується в кінці набору даних.\nДавайте розрахуємо загальний ВВП кожної країни в певний момент часу. Для цього створимо нову змінну gdp_billion в якій перемножимо змінні “кількість населення” на “ВВП на душу населення” та поділимо на один мільярд:За допомогою аргументів .та .можна змінювати й позицію запису нової змінної:Інколи необхідно свторити стовпчик індексів: порядковий номер спостереження. Для цього можна використати функцію row_number():Або використати базовий синтаксис R:Якщо ж хочется залишити лише розрахунковий стовпчик — використовується функція transmute(). При цьому вона дає можливість залишити й певні стовпчики з оригінального набору даних.Залишимо змінну country та розрахуємо загальний ВВП:","code":"\ngapminder %>% \n  mutate(gdp_billion = pop * gdpPercap / 10^9)\n## # A tibble: 1,704 x 7\n##    country     continent  year lifeExp      pop gdpPercap gdp_billion\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>       <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n##  2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n##  3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n##  4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n##  5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n##  6 Afghanistan Asia       1977    38.4 14880372      786.       11.7 \n##  7 Afghanistan Asia       1982    39.9 12881816      978.       12.6 \n##  8 Afghanistan Asia       1987    40.8 13867957      852.       11.8 \n##  9 Afghanistan Asia       1992    41.7 16317921      649.       10.6 \n## 10 Afghanistan Asia       1997    41.8 22227415      635.       14.1 \n## # ... with 1,694 more rows\ngapminder %>% \n  mutate(gdp_billion = pop * gdpPercap / 10^9,\n         .after = year)\n## # A tibble: 1,704 x 7\n##    country     continent  year gdp_billion lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>       <dbl>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952        6.57    28.8  8425333      779.\n##  2 Afghanistan Asia       1957        7.59    30.3  9240934      821.\n##  3 Afghanistan Asia       1962        8.76    32.0 10267083      853.\n##  4 Afghanistan Asia       1967        9.65    34.0 11537966      836.\n##  5 Afghanistan Asia       1972        9.68    36.1 13079460      740.\n##  6 Afghanistan Asia       1977       11.7     38.4 14880372      786.\n##  7 Afghanistan Asia       1982       12.6     39.9 12881816      978.\n##  8 Afghanistan Asia       1987       11.8     40.8 13867957      852.\n##  9 Afghanistan Asia       1992       10.6     41.7 16317921      649.\n## 10 Afghanistan Asia       1997       14.1     41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  mutate(record = row_number(),\n         .before = country)\n## # A tibble: 1,704 x 7\n##    record country     continent  year lifeExp      pop gdpPercap\n##     <int> <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1      1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2      2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3      3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4      4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5      5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6      6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7      7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8      8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9      9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10     10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  mutate(record = seq(1:n()),\n         .before = country)\n## # A tibble: 1,704 x 7\n##    record country     continent  year lifeExp      pop gdpPercap\n##     <int> <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1      1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2      2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3      3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4      4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5      5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6      6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7      7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8      8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9      9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10     10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder %>% \n  transmute(country,\n            gdp_billion = pop * gdpPercap / 10^9)\n## # A tibble: 1,704 x 2\n##    country     gdp_billion\n##    <fct>             <dbl>\n##  1 Afghanistan        6.57\n##  2 Afghanistan        7.59\n##  3 Afghanistan        8.76\n##  4 Afghanistan        9.65\n##  5 Afghanistan        9.68\n##  6 Afghanistan       11.7 \n##  7 Afghanistan       12.6 \n##  8 Afghanistan       11.8 \n##  9 Afghanistan       10.6 \n## 10 Afghanistan       14.1 \n## # ... with 1,694 more rows"},{"path":"dplyr.html","id":"group_by","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.9 dplyr::group_by() та summarise()","text":"Ще однією популярною задачею є групування та агрегація даних: розрахунок певних статистик чи значень для окремих груп.\nДля цього використовується функції group_by() та summarise(), які, як правило, використовуються разом.Для прикладу, розрахуємо середню (mean()) очікувану тривалість життя для кожного континенту. Для цього спочатку групуємо дані, а потім розраховуємо статистичний показник, який назвемо mean_life_exp:Аналогічно, ми можемо розраховувати одночасно декілька статистик. Додамо до розрахунку медіану (median()) та стандартне відхилення (sd()) очікуваної тривалості життя:Слід звернути увагу, що всі зазначені вище статистики в R чутливі до пропущених значень: у разі їх наявності, функції будуть повертати NA (available). Для того, щоб при розрахунку статистик не враховувались пропущені значення необхідно додати аргумент na.rm = TRUE.","code":"\ngapminder %>% \n  group_by(continent) %>% \n  summarise(mean_life_exp = mean(lifeExp))\n## # A tibble: 5 x 2\n##   continent mean_life_exp\n##   <fct>             <dbl>\n## 1 Africa             48.9\n## 2 Americas           64.7\n## 3 Asia               60.1\n## 4 Europe             71.9\n## 5 Oceania            74.3\ngapminder %>% \n  group_by(continent) %>% \n  summarise(mean_life_exp = mean(lifeExp),\n            md_life_exp = median(lifeExp),\n            sd_life_exp = sd(lifeExp))\n## # A tibble: 5 x 4\n##   continent mean_life_exp md_life_exp sd_life_exp\n##   <fct>             <dbl>       <dbl>       <dbl>\n## 1 Africa             48.9        47.8        9.15\n## 2 Americas           64.7        67.0        9.35\n## 3 Asia               60.1        61.8       11.9 \n## 4 Europe             71.9        72.2        5.43\n## 5 Oceania            74.3        73.7        3.80"},{"path":"dplyr.html","id":"across","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.10 dplyr::across()","text":"Але що, якщо нам необхідно розрахувати, наприклад, середні значення для всіх числових стовпчиків? Звичайно можна перерахувати їх всіх вручну:Але якщо числових змінних багато — такий підхід буде неоптимальним.\nВ таких випадках краще скористатися функцією across(). Продемонструю декілька варіантів.Для початку розрахуємо, як в попередньому прикладі, середні значення для числових змінних:Або можна перелічити потрібні змінні у векторі:Якщо уважно придивитися до результатів, то видно, що результати розрахунку повертаються з тими ж названими, як в оригінальному наборі даних. Якщо показати такий розрахунок третій стороні - можуть виникнути проблеми сприйняття. Як бути? Насправді функція across() досить гнучка і розробники передбачили такий варіант. Для цього нам знадобиться аргумент .names, де ми вкажемо правило запису назв результуючих змінних:І навіть розрахунки декількох різних статистик теж можливий. Для цього їх перелік необхідно записати списоком в аргументів функції across():","code":"\ngapminder %>% \n  group_by(continent) %>% \n  summarise(mean_life_exp = mean(lifeExp),\n            mean_pop = mean(pop),\n            mean_gdpPercap = mean(gdpPercap))\n## # A tibble: 5 x 4\n##   continent mean_life_exp  mean_pop mean_gdpPercap\n##   <fct>             <dbl>     <dbl>          <dbl>\n## 1 Africa             48.9  9916003.          2194.\n## 2 Americas           64.7 24504795.          7136.\n## 3 Asia               60.1 77038722.          7902.\n## 4 Europe             71.9 17169765.         14469.\n## 5 Oceania            74.3  8874672.         18622.\ngapminder %>% \n  select(-year) %>% # прибираємо змінну року\n  group_by(continent) %>% \n  summarise(across(where(is.numeric), mean))\n## # A tibble: 5 x 4\n##   continent lifeExp       pop gdpPercap\n##   <fct>       <dbl>     <dbl>     <dbl>\n## 1 Africa       48.9  9916003.     2194.\n## 2 Americas     64.7 24504795.     7136.\n## 3 Asia         60.1 77038722.     7902.\n## 4 Europe       71.9 17169765.    14469.\n## 5 Oceania      74.3  8874672.    18622.\ngapminder %>% \n  group_by(continent) %>% \n  summarise(across(lifeExp:gdpPercap, mean))\n## # A tibble: 5 x 4\n##   continent lifeExp       pop gdpPercap\n##   <fct>       <dbl>     <dbl>     <dbl>\n## 1 Africa       48.9  9916003.     2194.\n## 2 Americas     64.7 24504795.     7136.\n## 3 Asia         60.1 77038722.     7902.\n## 4 Europe       71.9 17169765.    14469.\n## 5 Oceania      74.3  8874672.    18622.\ngapminder %>% \n  group_by(continent) %>% \n  summarise(across(lifeExp:gdpPercap,\n                   mean,\n                   .names = \"mean_{.col}\"))\n## # A tibble: 5 x 4\n##   continent mean_lifeExp  mean_pop mean_gdpPercap\n##   <fct>            <dbl>     <dbl>          <dbl>\n## 1 Africa            48.9  9916003.          2194.\n## 2 Americas          64.7 24504795.          7136.\n## 3 Asia              60.1 77038722.          7902.\n## 4 Europe            71.9 17169765.         14469.\n## 5 Oceania           74.3  8874672.         18622.\ngapminder %>% \n  group_by(continent) %>% \n  summarise(across(lifeExp:gdpPercap,\n                   list(avg = mean, stdev = sd, md = median),\n                   .names = \"{.fn}_{.col}\"))\n## # A tibble: 5 x 10\n##   continent avg_lifeExp stdev_lifeExp md_lifeExp   avg_pop  stdev_pop    md_pop\n##   <fct>           <dbl>         <dbl>      <dbl>     <dbl>      <dbl>     <dbl>\n## 1 Africa           48.9          9.15       47.8  9916003.  15490923.  4579311 \n## 2 Americas         64.7          9.35       67.0 24504795.  50979430.  6227510 \n## 3 Asia             60.1         11.9        61.8 77038722. 206885205. 14530830.\n## 4 Europe           71.9          5.43       72.2 17169765.  20519438.  8551125 \n## 5 Oceania          74.3          3.80       73.7  8874672.   6506342.  6403492.\n## # ... with 3 more variables: avg_gdpPercap <dbl>, stdev_gdpPercap <dbl>,\n## #   md_gdpPercap <dbl>"},{"path":"dplyr.html","id":"count","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.11 dplyr::count()","text":"Якщо нам необхідно порахувати кількість значень в групі, то це можна зробити за допомогою group_by() та summarise(). Підрахуємо кількість країн на кожному континенті у наборі даних. Оскільки для кожної країни є 12 спостережень (з 1952 по 2007 рік кожні 5 років), необхідно враховувати тільки унікальні значення - для таких випадків є функція distinct():Але є простіший варіант - через функцію count():","code":"\ngapminder %>% \n  group_by(continent) %>% \n  distinct(country) %>% # унікальні значення\n  summarise(n = n())\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa       52\n## 2 Americas     25\n## 3 Asia         33\n## 4 Europe       30\n## 5 Oceania       2\ngapminder %>% \n  count(continent) %>% \n  mutate(n = n / 12) # поправка на к-ть років\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <dbl>\n## 1 Africa       52\n## 2 Americas     25\n## 3 Asia         33\n## 4 Europe       30\n## 5 Oceania       2"},{"path":"dplyr.html","id":"case","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.12 dplyr::case_when()","text":"Яка маніпуляція з даними обходиться без конструкції “- else?” В базовому синтаксисі R є функція ifelse() але я пропоную користуватися векторизованим варіантом з dplyr case_when().\nДля прикладу давайте створимо нову номінативну змінну, яка буде оцінювати середню очікувану тривалість життя в форматі “низька-середня-висока”:","code":"\ngapminder %>% \n  group_by(country) %>% \n  summarise(mean_life_exp = mean(lifeExp)) %>% \n  mutate(\n    bin_life = case_when(\n      mean_life_exp > 70 ~ \"hight\", # умова 1\n      mean_life_exp > 50 & mean_life_exp <= 70 ~ \"medium\", # умова 2\n      TRUE ~ \"low\" # для всіх інших випадків\n    )\n  )\n## # A tibble: 142 x 3\n##    country     mean_life_exp bin_life\n##    <fct>               <dbl> <chr>   \n##  1 Afghanistan          37.5 low     \n##  2 Albania              68.4 medium  \n##  3 Algeria              59.0 medium  \n##  4 Angola               37.9 low     \n##  5 Argentina            69.1 medium  \n##  6 Australia            74.7 hight   \n##  7 Austria              73.1 hight   \n##  8 Bahrain              65.6 medium  \n##  9 Bangladesh           49.8 low     \n## 10 Belgium              73.6 hight   \n## # ... with 132 more rows"},{"path":"dplyr.html","id":"pivot","chapter":" 2 Маніпуляції з даними за допомогою dplyr і не тільки","heading":"2.3.13 Обертання даних: pivot()","text":"Бувають випадки, коли дані приходять в “неохайному,” незручному форматі:одна змінна розташована у декількох стовпчиках.одна змінна розташована у декількох стовпчиках.одне спостереження може бути розкидане по кільком рядкам.одне спостереження може бути розкидане по кільком рядкам.Типовим прикладом таких даних можуть бути дані Всесвітнього банку. Давайте завантажимо їх і подивимось, як привести їх до “охайних.” В таких випадках нам допоможуть функції pivot_longer() та pivot_wider() з пакету tidyr (частина tidyverse).В якості прикладу завантажимо інформацію по показнику Прямі іноземні інвестиції (Foreign direct investment, net (BoP, current US$)).\nРисунок 2.1: Перегляд перших значень набору даних Всесвытнього банку\nНа що звертаємо увагу:Перші 4 рядочки неінформативні.Перші 4 рядочки неінформативні.Дані зберігаються у “широкому форматі”: змінна року розташована горизонтально, що може ускладнити аналіз.Дані зберігаються у “широкому форматі”: змінна року розташована горизонтально, що може ускладнити аналіз.Завантажимо дані і одразу пропустимо перші 4 рядки за допомогою аргументу skip = 4:Використаємо функцію pivot_longer() для того щоб змінна року була окремим стовпчиком:З таким набором даних буде працювати значно зручніше.Для прикладу роботи функції pivot_wider() повернемося до датасету gapminder:Перевернемо його у широкий формат:В переважній більшості випадків вам знадобиться довгий формат даних. Але при потребі зберігання великих файлів - краще зберігати у широкому форматі, оскільки це збереже місце на диску.Збережемо результати широкого і довго формату набору даних gapminder та перевіремо їх розмір:Широкий формат в 1.7 рази менший.","code":"\nfdi <- read_csv(\"https://raw.githubusercontent.com/Aranaur/datasets/main/datasets/world_bank/Foreign_direct_investment/FDI.csv\",\n                skip = 4)\n\nfdi\n## # A tibble: 266 x 66\n##    `Country Name` `Country Code` `Indicator Name` `Indicator Code` `1960` `1961`\n##    <chr>          <chr>          <chr>            <chr>             <dbl>  <dbl>\n##  1 Aruba          ABW            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  2 Africa Easter~ AFE            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  3 Afghanistan    AFG            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  4 Africa Wester~ AFW            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  5 Angola         AGO            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  6 Albania        ALB            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  7 Andorra        AND            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  8 Arab World     ARB            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n##  9 United Arab E~ ARE            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n## 10 Argentina      ARG            Foreign direct ~ BN.KLT.DINV.CD       NA     NA\n## # ... with 256 more rows, and 60 more variables: `1962` <dbl>, `1963` <dbl>,\n## #   `1964` <dbl>, `1965` <dbl>, `1966` <dbl>, `1967` <dbl>, `1968` <dbl>,\n## #   `1969` <dbl>, `1970` <dbl>, `1971` <dbl>, `1972` <dbl>, `1973` <dbl>,\n## #   `1974` <dbl>, `1975` <dbl>, `1976` <dbl>, `1977` <dbl>, `1978` <dbl>,\n## #   `1979` <dbl>, `1980` <dbl>, `1981` <dbl>, `1982` <dbl>, `1983` <dbl>,\n## #   `1984` <dbl>, `1985` <dbl>, `1986` <dbl>, `1987` <dbl>, `1988` <dbl>,\n## #   `1989` <dbl>, `1990` <dbl>, `1991` <dbl>, `1992` <dbl>, `1993` <dbl>, ...\nfdi_longer <- fdi %>% \n  # змінимо формат назв стовпчиків\n  set_names(names(.) %>% str_to_lower() %>%  str_replace(\" \", \"_\")) %>% \n  # приберемо зайві\n  select(-c(indicator_name, indicator_code)) %>% \n  # обертаємо дані\n    pivot_longer(cols = -c(country_name, country_code), # використовуємо всі \n                                                        # крім country_name, country_code\n               names_to = \"year\", # назва нового стовпчика \n                                  # (роки з початкового набору даних)\n               values_to = \"fdi\") %>% # назва нового стовпчика \n                                      # (значення ПІІ до кожного року)\n  drop_na() # приберемо пропущені значення\n\nfdi_longer\n## # A tibble: 6,473 x 4\n##    country_name country_code year          fdi\n##    <chr>        <chr>        <chr>       <dbl>\n##  1 Aruba        ABW          1990  -130502793.\n##  2 Aruba        ABW          1991  -184748603.\n##  3 Aruba        ABW          1992    36983240.\n##  4 Aruba        ABW          1993    17932961.\n##  5 Aruba        ABW          1994    73184358.\n##  6 Aruba        ABW          1995     5530726.\n##  7 Aruba        ABW          1996   -84134078.\n##  8 Aruba        ABW          1997  -197597765.\n##  9 Aruba        ABW          1998   -82178771.\n## 10 Aruba        ABW          1999  -469329609.\n## # ... with 6,463 more rows\ngapminder\n## # A tibble: 1,704 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows\ngapminder_wide <- gapminder %>% \n  pivot_wider(names_from = year,\n              values_from = c(lifeExp:gdpPercap))\n\ngapminder_wide\n## # A tibble: 142 x 38\n##    country     continent lifeExp_1952 lifeExp_1957 lifeExp_1962 lifeExp_1967\n##    <fct>       <fct>            <dbl>        <dbl>        <dbl>        <dbl>\n##  1 Afghanistan Asia              28.8         30.3         32.0         34.0\n##  2 Albania     Europe            55.2         59.3         64.8         66.2\n##  3 Algeria     Africa            43.1         45.7         48.3         51.4\n##  4 Angola      Africa            30.0         32.0         34           36.0\n##  5 Argentina   Americas          62.5         64.4         65.1         65.6\n##  6 Australia   Oceania           69.1         70.3         70.9         71.1\n##  7 Austria     Europe            66.8         67.5         69.5         70.1\n##  8 Bahrain     Asia              50.9         53.8         56.9         59.9\n##  9 Bangladesh  Asia              37.5         39.3         41.2         43.5\n## 10 Belgium     Europe            68           69.2         70.2         70.9\n## # ... with 132 more rows, and 32 more variables: lifeExp_1972 <dbl>,\n## #   lifeExp_1977 <dbl>, lifeExp_1982 <dbl>, lifeExp_1987 <dbl>,\n## #   lifeExp_1992 <dbl>, lifeExp_1997 <dbl>, lifeExp_2002 <dbl>,\n## #   lifeExp_2007 <dbl>, pop_1952 <int>, pop_1957 <int>, pop_1962 <int>,\n## #   pop_1967 <int>, pop_1972 <int>, pop_1977 <int>, pop_1982 <int>,\n## #   pop_1987 <int>, pop_1992 <int>, pop_1997 <int>, pop_2002 <int>,\n## #   pop_2007 <int>, gdpPercap_1952 <dbl>, gdpPercap_1957 <dbl>, ...\nwrite_csv(gapminder, \"docs/data/gapminder.csv\")\nwrite_csv(gapminder_wide, \"docs/data/gapminder_wide.csv\")\n\nfs::file_size(\"docs/data/gapminder.csv\")\n## 80.2K\nfs::file_size(\"docs/data/gapminder_wide.csv\")\n## 47.3K"},{"path":"simple_regression.html","id":"simple_regression","chapter":" 3 Проста лінійна регресія","heading":" 3 Проста лінійна регресія","text":"Економетрика - це дисципліна, яка займається дослідженням взаємозв’язків між даними. Для цього нам знадобиться знання статистики, математики, економіки. Це може допомогти вирішити дві головні задачі дослідження:пояснити зв’язки: визначити які показники впливають сильніше на певні процеси, а які менше.пояснити зв’язки: визначити які показники впливають сильніше на певні процеси, а які менше.будувати прогнози: як буде розвиватися процес в подальшому або при інших умовах.будувати прогнози: як буде розвиватися процес в подальшому або при інших умовах.Уявіть, що вам необхідно оцінити ефективність витрат рекламної компанії, тенденцію розвитку витрат виробництва, прогноз валового внутрішнього продукту тощо. На кожне з цих завдань може допомогти знайти відповідь економетрика, хоча з точки зору прогнозної сили, напевно, слід піти далі і звернутися до алгоритмів машинного навчання або нейронних мереж, хоча й там є свої особливості. На мою думку, економетрика на рівні зі статистикою - це чудовий фундамент для подальшого вивчення машинного навчання.Для економетричного дослідження необхідно будувати математичні моделі - спрощений варіант реальних об’єктів дослідження. Виглядають вони частіше за все, як певні рівняння, наприклад опишемо залежність заробітної плати робітника від його освіти, досвіду роботи та навичок. Таку залежність можна описати наступним чином:\\[\ny = f(x_1, x_2, x_3),\n\\tag{3.1}\n\\]\nде\n\\(y\\) — заробітна плата,\n\\(x_1\\) — рівень освіти,\n\\(x_2\\) — досвід роботи,\n\\(x_3\\) — навички (знання мов програмування, статистики тощо),\n\\(f\\) — функція залежності: описує яким саме чином \\(x_i, =\\overline{1,3}\\) впливають на \\(y\\).Змінна \\(y\\), яку ми намагаємось пояснити, називається залежною, а змінні \\(x_i\\), за допомогою яких ми намагаємось пояснити або спрогнозувати залежну змінну, називають незалежними. Хоча можуть зустрічатися і альтернативні визначення:Зверніть увагу, що ми суб’єктивно оголосили, що на заробітну плату впливають зазначені показники. При альтернативних дослідженні і форма залежності, і перелік змінних може бути іншим. Та й взагалі, можливо ми захочемо пояснити вже рівень освіти за допомогою заробітної плати, досвіду роботи і навичок. Все це ми визначаємо на основі своїх знань, досвіду та доступної інформації.В якості джерел даних можуть виступати:Перехресні дані: дані зібрані по різним об’єктам дослідження (персонал, компанії, держави, сфери тощо). Часто такі дані були зібрані за допомогою простої випадкової вибірки.Часові ряди: дані по одному чи декількох об’єктах дослідження впродовж певного періоду часу (курси валют, ВВП, пасажиропотік тощо). Головною особливістю таких даних виступає часова впорядкованість (від минулого до сучасного) та частота даних (однаковий інтервал запису даних).Панельні дані: поєднуть в собі перехресні дані та часові ряди, вони показують, як об’єкти дослідження змінювались з часом.Функція залежності \\(f\\) може мати різну форму та характер. Ми не знаємо її зазделегідь і намагаємось підібрати найкращий варіант з декількох альтернатив.","code":"\nlibrary(tidyverse)\nstarwars\n## # A tibble: 87 x 14\n##    name     height  mass hair_color skin_color eye_color birth_year sex   gender\n##    <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n##  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~\n##  2 C-3PO       167    75 <NA>       gold       yellow         112   none  mascu~\n##  3 R2-D2        96    32 <NA>       white, bl~ red             33   none  mascu~\n##  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~\n##  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~\n##  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~\n##  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~\n##  8 R5-D4        97    32 <NA>       white, red red             NA   none  mascu~\n##  9 Biggs D~    183    84 black      light      brown           24   male  mascu~\n## 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~\n## # ... with 77 more rows, and 5 more variables: homeworld <chr>, species <chr>,\n## #   films <list>, vehicles <list>, starships <list>\neconomics\n## # A tibble: 574 x 6\n##    date         pce    pop psavert uempmed unemploy\n##    <date>     <dbl>  <dbl>   <dbl>   <dbl>    <dbl>\n##  1 1967-07-01  507. 198712    12.6     4.5     2944\n##  2 1967-08-01  510. 198911    12.6     4.7     2945\n##  3 1967-09-01  516. 199113    11.9     4.6     2958\n##  4 1967-10-01  512. 199311    12.9     4.9     3143\n##  5 1967-11-01  517. 199498    12.8     4.7     3066\n##  6 1967-12-01  525. 199657    11.8     4.8     3018\n##  7 1968-01-01  531. 199808    11.7     5.1     2878\n##  8 1968-02-01  534. 199920    12.3     4.5     3001\n##  9 1968-03-01  544. 200056    11.7     4.1     2877\n## 10 1968-04-01  544  200208    12.3     4.6     2709\n## # ... with 564 more rows\nlibrary(gapminder)\ngapminder\n## # A tibble: 1,704 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ... with 1,694 more rows"},{"path":"simple_regression.html","id":"проста-лінійна-регресія","chapter":" 3 Проста лінійна регресія","heading":"3.1 Проста лінійна регресія","text":"Проста лінійна регресія — це модель, яка пояснює залежність між двома змінними за допомогою лінійного взаємозв’язку.Роботу такої регресії краще пояснити на прикладі. В нашому розпорядженні є набір даних про вагу та зріст вибірки чоловіків та жінок:Конвертуємо значення в кілограми і сантиметри та візуалізуємо підвибірку по чоловікам:Припустимо, що взаємозв’язок між вагою і зростом - лінійний. Такі випадки на практиці досить рідко зустрічаються і пізніше ми познайомимось з іншими варіантами.Рівняння прямої виглядає наступним чином:\n\\[\ny_i = \\beta_0 + \\beta_1x_i + u_i\n\\tag{3.2}\n\\]\nПідставимо конкретні змінні у рівняння, отримаємо:\n\\[\nHeight_i = \\beta_0 + \\beta_1Weight_i + u_i\n\\tag{3.3}\n\\]\nРівняння (3.2) та (3.3) називаються простою лінійною регресією або парною лінійною регресією.Розглянемо складові рівняння (3.2):\\(y\\): залежна змінна.\\(y\\): залежна змінна.\\(\\beta_0\\): вільний параметр моделі, який відповідає за точку перетину прямої з вістю ординат.\\(\\beta_0\\): вільний параметр моделі, який відповідає за точку перетину прямої з вістю ординат.\\(\\beta_1\\): залежний параметр моделі, який відповідає за кут нахилу прямої.\\(\\beta_1\\): залежний параметр моделі, який відповідає за кут нахилу прямої.\\(x\\): незалежна змінна.\\(x\\): незалежна змінна.\\(u\\): залишки моделі.\\(u\\): залишки моделі.Для того щоб тримати рівняння прямої, нам необхідно підібрати значення параметрів моделі: \\(\\hat{\\beta_0}\\) та \\(\\hat{\\beta_1}\\). Що значать “кришки” \\(^\\) над коєфіціентами? Справа в тому, що в нашому розпорядженні є тільки певна вибірка даних і провести ідеальну пряму через всі точки неможливо. Тому нам необхідно розрахувати оцінки параметрів моделі, які будуть задовільняти нас.Отже рівняння моделі набуває вигляду:\n\\[\n\\hat{y_i} = \\hat{\\beta_0} + \\hat{\\beta_1}x_i\n\\tag{3.4}\n\\]\nабо для нашого прикладу\n\\[\n\\hat{Height_i} = \\hat{\\beta_0} + \\hat{\\beta_1}Weight_i\n\\tag{3.5}\n\\]\nДавайте для початку проведемо пряму, яка відповідає середньому значенню ваги чоловіків по вибірці:Очевидно, що така “модель” є неоптимальною і вона має значні залишки: відхилення модельних значень від фактичнихПозитивні відхилення розташовані вище модельних значень, а від’ємні - нижче.Такі моделі вже мають значно менші відхилення. Але вони були побудовані “на око” без точних математичних розрахунків. Як провести оптимізацію процесу підбору моделі? Для цього ми вводимо функцію втрат (loss function), мінімізуючи котру ми будемо підбирати оптимальні значення \\(\\hat{\\beta_0}\\) та \\(\\hat{\\beta_1}\\). На перший погляд здається, що непоганою ідеєю було б розрахувати суму похибок \\(\\sum\\limits^{n}_{=1}{u_i}\\) для всіх альтернатив та обрати модель з найменшим значенням. Але такий підхід має значний недолік: представимо, що ми побудували дві моделі і отримали залишки \\(u_{m1} = (-10, -5, 5, 10)\\) для першої та \\(u_{m2} = (-100, -50, 50, 100)\\) для другої моделі. Сума залишків для обох моделей дорівнює нулю, але це не значит, що моделі не помиляються. Позитивні та негативні похибки компенсують один одного, при цьому коливання похибок другої моделі значно більші. Тож такий підхід нам не підходить.Тому для оцінювання параметрів моделі в лінійній регресії пропонується використовувати метод найменших квадратів (МНК, ordinary least squares, OLS): серед альтернатив обbраємо ту, для котрої сума квадратів відхилення буде мінімальною.\n\\[\n\\sum\\limits^{n}_{=1}{u_i^2} = u_1^2 + u_2^2 + \\dots + u_n^2 \\rightarrow min\n\\tag{3.6}\n\\]\nЧому слід брати квадрат відхилення, а не абсолютні значення \\(\\left |{u_1}\\right | + \\left |{u_2}\\right | + \\dots + \\left |{u_n}\\right |\\)? Такий підхід має значний недолік: абсолютні значення не мають неперервної похідної, що робить таку функцію негладкою. До того ж квадрат похибок “штрафують” модель сильніше з більших відхилень. Як альтернативу можна обрати інші парні степені похибок, такі як 4 або 6, але і там є певні складнощі. Тому на практиці частіше за всі інші альтернативи обирають МНК.Подивимось, як працює мінімізація суми квадратів залишків.\n\\[\n\\sum\\limits^{n}_{=1}{u_i^2} = \\sum\\limits^{n}_{=1}(y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i)^2 \\rightarrow min\n\\tag{3.7}\n\\]\nВізьмемо похідні по \\(\\hat{\\beta_0}\\) та \\(\\hat{\\beta_1}\\):\n\\[\n\\left\\{\\begin{matrix}\n -2\\sum\\limits^{n}_{=1}(y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i) = 0 & \\\\ \n-2\\sum\\limits^{n}_{=1}x_i(y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i) = 0 & \n\\end{matrix}\\right.\n\\tag{3.8}\n\\]Розкриємо дужки першого рівняння:\n\\[\n\\left\\{\\begin{matrix}\n\\sum\\limits^{n}_{=1}y_i - n\\hat{\\beta_0} - \\hat{\\beta_1}x_i = 0 & \\\\ \n\\sum\\limits^{n}_{=1}x_i(y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i) = 0 & \n\\end{matrix}\\right.\n\\tag{3.9}\n\\]Поділимо перше рівняння на \\(n\\):\n\\[\n\\left\\{\\begin{matrix}\n\\overline{y} - \\hat{\\beta_0} - \\hat{\\beta_1}\\overline{x} = 0 & \\\\ \n\\sum\\limits^{n}_{=1}x_i(y_i - \\hat{\\beta_0} - \\hat{\\beta_1}x_i) = 0 & \n\\end{matrix}\\right.\n\\tag{3.10}\n\\]\nЗ першого рівняння виразимо \\(\\hat{\\beta_0}\\) і підставимо у друге:\n\\[\n\\left\\{\\begin{matrix}\n\\hat{\\beta_0} = \\overline{y} - \\hat{\\beta_1}\\overline{x} & \\\\ \n\\sum\\limits^{n}_{=1}x_i(y_i - (\\overline{y} - \\hat{\\beta_1}\\overline{x}) - \\hat{\\beta_1}x_i) = 0 & \n\\end{matrix}\\right.\n\\tag{3.11}\n\\]\nРозкриємо дужки у другому рівнянні:\n\\[\n\\left\\{\\begin{matrix}\n\\hat{\\beta_0} = \\overline{y} - \\hat{\\beta_1}\\overline{x} & \\\\ \n\\sum\\limits^{n}_{=1}x_i(y_i - \\overline{y}) =  \\hat{\\beta_1}\\sum\\limits^{n}_{=1}x_i(x_i - \\overline{x}) \n\\end{matrix}\\right.\n\\tag{3.12}\n\\]\nОскільки\n\\[\\sum\\limits^{n}_{=1}x_i(y_i - \\overline{y}) = \\sum\\limits^{n}_{=1}(x_i - \\overline{x})^2\\]\nта\n\\[\\sum\\limits^{n}_{=1}x_i(y_i - \\overline{y}) = \\sum\\limits^{n}_{=1}(x_i - \\overline{x})(y_i - \\overline{y}),\\]\nтоді за умови\n\\[\n\\sum\\limits^{n}_{=1}(x_i - \\overline{x})^2 > 0\n\\tag{3.13}\n\\]\nоцінки параметрів моделі \\(\\hat{\\beta_0}\\) та \\(\\hat{\\beta_1}\\) будуть дорівнювати:\n\\[\n\\left\\{\\begin{matrix}\n\\hat{\\beta_0} = \\overline{y} - \\hat{\\beta_1}\\overline{x} & \\\\ \n\\hat{\\beta_1} = \\frac{\\sum\\limits^{n}_{=1}(x_i - \\overline{x})(y_i - \\overline{y})}{\\sum\\limits^{n}_{=1}(x_i - \\overline{x})^2} = \\frac{\\overline{xy} - \\overline{x}\\overline{y}}{\\overline{x^2} - \\overline{x}^2}\n\\end{matrix}\\right.\n\\tag{3.14}\n\\]\nДавайте поетапно розрахуємо значення \\(\\hat{\\beta_0}\\) та \\(\\hat{\\beta_1}\\) для нашого прикладу з вагою і зростом:Додамо розрахункові значення \\(Height_{kg}^2\\) та \\(Height_{kg}*Weight_{cm}\\):Знайдемо середнє значення для кожного стовпчика:Тепер можемо розрахувати оцінки параметрів моделі:Отже рівняння простої лінійної регресії для нашого прикладу буде виглядати:\n\\[\\hat{y_i} = -96 + 1.02 * \\hat{x}\\]\nЗвичайно, на практиці оцінки параметрів моделі за МНК розраховуються за допомогою комп’ютера. Для цього, в R є функція lm(), де першим аргументом вказується формула залежності, а другим набір даних:Результат моделі male_ols зберігається у вигляді списку, з якого ми можемо отримати залишки, параметри моделі, модельні значення тощо:Побудуємо візуалізацію отриманих результатів за допомогою ggplot2абоbookdown::render_book(“index.Rmd,” output_dir = “docs”)","code":"\nweight_height <- read_csv(\"https://raw.githubusercontent.com/Aranaur/datasets/main/datasets/weight-height.csv\")\n\nweight_height\n## # A tibble: 10,000 x 3\n##    Gender Height Weight\n##    <chr>   <dbl>  <dbl>\n##  1 Male     73.8   242.\n##  2 Male     68.8   162.\n##  3 Male     74.1   213.\n##  4 Male     71.7   220.\n##  5 Male     69.9   206.\n##  6 Male     67.3   152.\n##  7 Male     68.8   184.\n##  8 Male     68.3   168.\n##  9 Male     67.0   176.\n## 10 Male     63.5   156.\n## # ... with 9,990 more rows\n# фіксуємо генератор випадкових величин\nset.seed(2022)\n\nmale <- weight_height %>% \n  # беремо тільки чоловіків\n  filter(Gender == \"Male\") %>%\n  # формуємо випадкову підвибірку\n  slice_sample(n = 100) %>% \n  # конвертуємо значення\n  mutate(Height_kg = Height * 2.54,\n         Weight_cm = Weight * 0.45)\n\n# візуалізуємо\nmale %>% \n  ggplot(aes(Height_kg, Weight_cm)) +\n  geom_point() +\n  labs(x = \"Зріст (см)\",\n       y = \"Вага (кг)\")\nmale %>% \n  ggplot(aes(Height_kg, Weight_cm)) +\n  geom_point() +\n  geom_hline(aes(yintercept = mean(Weight_cm)), color = \"blue\") +\n  labs(x = \"Зріст (см)\",\n       y = \"Вага (кг)\")\nmale %>% \n  mutate(fit1 = mean(Weight_cm),\n         resid1 = Weight_cm - fit1) %>% \n  ggplot(aes(Height_kg, Weight_cm)) +\n  geom_point() +\n  geom_hline(aes(yintercept = mean(Weight_cm)), color = \"blue\") +\n  geom_segment(aes(xend = Height_kg, yend = fit1), alpha = 0.2, color = \"red\") + \n  labs(x = \"Зріст (см)\",\n       y = \"Вага (кг)\")\nmale %>% \n  select(Height_kg, Weight_cm)\n## # A tibble: 100 x 2\n##    Height_kg Weight_cm\n##        <dbl>     <dbl>\n##  1      182.      89.4\n##  2      174.      80.9\n##  3      175.      83.9\n##  4      182.      86.6\n##  5      177.      82.9\n##  6      184.     101. \n##  7      185.      84.8\n##  8      169.      79.2\n##  9      170.      74.0\n## 10      187.      94.5\n## # ... with 90 more rows\nmale %>% \n  select(Height_kg, Weight_cm) %>% \n  mutate(Height_kg_sq = Height_kg ^ 2,\n         Height_Weight = Height_kg * Weight_cm)\n## # A tibble: 100 x 4\n##    Height_kg Weight_cm Height_kg_sq Height_Weight\n##        <dbl>     <dbl>        <dbl>         <dbl>\n##  1      182.      89.4       33197.        16286.\n##  2      174.      80.9       30197.        14062.\n##  3      175.      83.9       30469.        14644.\n##  4      182.      86.6       33302.        15799.\n##  5      177.      82.9       31233.        14651.\n##  6      184.     101.        33907.        18675.\n##  7      185.      84.8       34065.        15647.\n##  8      169.      79.2       28566.        13385.\n##  9      170.      74.0       28917.        12583.\n## 10      187.      94.5       34841.        17637.\n## # ... with 90 more rows\nmale %>% \n  select(Height_kg, Weight_cm) %>% \n  mutate(Height_kg_sq = Height_kg ^ 2,\n         Height_Weight = Height_kg * Weight_cm) %>% \n  summarise(across(Height_kg:Height_Weight,\n            mean,\n            .names = \"mean_{.col}\"))\n## # A tibble: 1 x 4\n##   mean_Height_kg mean_Weight_cm mean_Height_kg_sq mean_Height_Weight\n##            <dbl>          <dbl>             <dbl>              <dbl>\n## 1           176.           83.8            30892.             14780.\nmale %>% \n  select(Height_kg, Weight_cm) %>% \n  mutate(Height_kg_sq = Height_kg ^ 2,\n         Height_Weight = Height_kg * Weight_cm) %>% \n  summarise(across(Height_kg:Height_Weight,\n            mean,\n            .names = \"mean_{.col}\")) %>% \n  transmute(beta_1 = (mean_Height_Weight - mean_Height_kg * mean_Weight_cm)/(mean_Height_kg_sq - mean_Height_kg^2),\n            beta_0 = mean_Weight_cm - beta_1 * mean_Height_kg)\n## # A tibble: 1 x 2\n##   beta_1 beta_0\n##    <dbl>  <dbl>\n## 1   1.02  -96.0\n# у формулі ліворуч від ~ знаходиться залежна змінна\n# праворуч від ~ незалежні змінні\nmale_ols <- lm(Weight_cm ~ Height_kg, data = male)\nmale_ols\n## \n## Call:\n## lm(formula = Weight_cm ~ Height_kg, data = male)\n## \n## Coefficients:\n## (Intercept)    Height_kg  \n##     -95.999        1.024\n# Оцінки параметрів моделі\nmale_ols$coefficients\n## (Intercept)   Height_kg \n##  -95.998717    1.024054\n# Модельні значення в тібблі\nas_tibble(male_ols$fitted.values)\n## # A tibble: 100 x 1\n##    value\n##    <dbl>\n##  1  90.6\n##  2  82.0\n##  3  82.8\n##  4  90.9\n##  5  85.0\n##  6  92.6\n##  7  93.0\n##  8  77.1\n##  9  78.1\n## 10  95.1\n## # ... with 90 more rows\nmale %>% \n  ggplot(aes(Height_kg, Weight_cm)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(x = \"Зріст (см)\",\n       y = \"Вага (кг)\")\nmale %>% \n  mutate(fit_ols = male_ols$fitted.values) %>% \n  ggplot(aes(Height_kg, Weight_cm)) +\n  geom_point() +\n  geom_line(aes(Height_kg, fit_ols), color = \"blue\")"},{"path":"multiple_regression.html","id":"multiple_regression","chapter":" 4 Множинна лінійна регресія","heading":" 4 Множинна лінійна регресія","text":"text","code":""},{"path":"multicollinearity.html","id":"multicollinearity","chapter":" 5 Мультиколінеарність","heading":" 5 Мультиколінеарність","text":"text","code":""},{"path":"heteroskedasticity.html","id":"heteroskedasticity","chapter":" 6 Гетероскедастичність","heading":" 6 Гетероскедастичність","text":"text","code":""},{"path":"regularization.html","id":"regularization","chapter":" 7 Регуляризація","heading":" 7 Регуляризація","text":"text","code":""},{"path":"time_series.html","id":"time_series","chapter":" 8 Регресійний аналіз часових рядів","heading":" 8 Регресійний аналіз часових рядів","text":"text","code":""},{"path":"glm.html","id":"glm","chapter":" 9 GLM","heading":" 9 GLM","text":"text","code":""},{"path":"references.html","id":"references","chapter":"Література","heading":"Література","text":"","code":""}]
